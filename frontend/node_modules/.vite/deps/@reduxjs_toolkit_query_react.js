import { __toESM } from "./chunk-C3DNirgS.js";
import { require_react } from "./react-CYOtBTfM.js";
import { configureStore, createSelector } from "./redux-toolkit.modern-DdR6sdOA.js";
import { NamedSchemaError, QueryStatus, _NEVER, buildCreateApi, copyWithStructuralSharing, coreModule, coreModuleName, defaultSerializeQueryArgs, fakeBaseQuery, fetchBaseQuery, retry, setupListeners, skipToken } from "./rtk-query.modern-BD4qpozQ.js";
import { Provider_default, ReactReduxContext, batch, shallowEqual, useDispatch, useSelector, useStore } from "./react-redux-CnLQERWB.js";

//#region node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
function capitalize(str) {
	return str.replace(str[0], str[0].toUpperCase());
}
function countObjectKeys(obj) {
	let count = 0;
	for (const _key in obj) count++;
	return count;
}
function isQueryDefinition(e) {
	return e.type === "query";
}
function isMutationDefinition(e) {
	return e.type === "mutation";
}
function isInfiniteQueryDefinition(e) {
	return e.type === "infinitequery";
}
function safeAssign(target, ...args) {
	return Object.assign(target, ...args);
}
var UNINITIALIZED_VALUE = Symbol();
function useStableQueryArgs(queryArgs) {
	const cache = (0, import_react.useRef)(queryArgs);
	const copy = (0, import_react.useMemo)(() => copyWithStructuralSharing(cache.current, queryArgs), [queryArgs]);
	(0, import_react.useEffect)(() => {
		if (cache.current !== copy) cache.current = copy;
	}, [copy]);
	return copy;
}
function useShallowStableValue(value) {
	const cache = (0, import_react.useRef)(value);
	(0, import_react.useEffect)(() => {
		if (!shallowEqual(cache.current, value)) cache.current = value;
	}, [value]);
	return shallowEqual(cache.current, value) ? cache.current : value;
}
var canUseDOM = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isDOM = /* @__PURE__ */ canUseDOM();
var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
var isReactNative = /* @__PURE__ */ isRunningInReactNative();
var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? import_react.useLayoutEffect : import_react.useEffect;
var useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
var noPendingQueryStateSelector = (selected) => {
	if (selected.isUninitialized) return {
		...selected,
		isUninitialized: false,
		isFetching: true,
		isLoading: selected.data !== void 0 ? false : true,
		status: QueryStatus.pending
	};
	return selected;
};
function pick(obj, ...keys) {
	const ret = {};
	keys.forEach((key) => {
		ret[key] = obj[key];
	});
	return ret;
}
var COMMON_HOOK_DEBUG_FIELDS = [
	"data",
	"status",
	"isLoading",
	"isSuccess",
	"isError",
	"error"
];
function buildHooks({ api, moduleOptions: { batch: batch$1, hooks: { useDispatch: useDispatch$1, useSelector: useSelector$1, useStore: useStore$1 }, unstable__sideEffectsInRender, createSelector: createSelector$1 }, serializeQueryArgs, context }) {
	const usePossiblyImmediateEffect = unstable__sideEffectsInRender ? (cb) => cb() : import_react.useEffect;
	return {
		buildQueryHooks,
		buildInfiniteQueryHooks,
		buildMutationHook,
		usePrefetch
	};
	function queryStatePreSelector(currentState, lastResult, queryArgs) {
		if (lastResult?.endpointName && currentState.isUninitialized) {
			const { endpointName } = lastResult;
			const endpointDefinition = context.endpointDefinitions[endpointName];
			if (queryArgs !== skipToken && serializeQueryArgs({
				queryArgs: lastResult.originalArgs,
				endpointDefinition,
				endpointName
			}) === serializeQueryArgs({
				queryArgs,
				endpointDefinition,
				endpointName
			})) lastResult = void 0;
		}
		let data = currentState.isSuccess ? currentState.data : lastResult?.data;
		if (data === void 0) data = currentState.data;
		const hasData = data !== void 0;
		const isFetching = currentState.isLoading;
		const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;
		const isSuccess = currentState.isSuccess || hasData && (isFetching && !lastResult?.isError || currentState.isUninitialized);
		return {
			...currentState,
			data,
			currentData: currentState.data,
			isFetching,
			isLoading,
			isSuccess
		};
	}
	function infiniteQueryStatePreSelector(currentState, lastResult, queryArgs) {
		if (lastResult?.endpointName && currentState.isUninitialized) {
			const { endpointName } = lastResult;
			const endpointDefinition = context.endpointDefinitions[endpointName];
			if (queryArgs !== skipToken && serializeQueryArgs({
				queryArgs: lastResult.originalArgs,
				endpointDefinition,
				endpointName
			}) === serializeQueryArgs({
				queryArgs,
				endpointDefinition,
				endpointName
			})) lastResult = void 0;
		}
		let data = currentState.isSuccess ? currentState.data : lastResult?.data;
		if (data === void 0) data = currentState.data;
		const hasData = data !== void 0;
		const isFetching = currentState.isLoading;
		const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;
		const isSuccess = currentState.isSuccess || isFetching && hasData;
		return {
			...currentState,
			data,
			currentData: currentState.data,
			isFetching,
			isLoading,
			isSuccess
		};
	}
	function usePrefetch(endpointName, defaultOptions) {
		const dispatch = useDispatch$1();
		const stableDefaultOptions = useShallowStableValue(defaultOptions);
		return (0, import_react.useCallback)((arg, options) => dispatch(api.util.prefetch(endpointName, arg, {
			...stableDefaultOptions,
			...options
		})), [
			endpointName,
			dispatch,
			stableDefaultOptions
		]);
	}
	function useQuerySubscriptionCommonImpl(endpointName, arg, { refetchOnReconnect, refetchOnFocus, refetchOnMountOrArgChange, skip = false, pollingInterval = 0, skipPollingIfUnfocused = false,...rest } = {}) {
		const { initiate } = api.endpoints[endpointName];
		const dispatch = useDispatch$1();
		const subscriptionSelectorsRef = (0, import_react.useRef)(void 0);
		if (!subscriptionSelectorsRef.current) {
			const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());
			if (typeof returnedValue !== "object" || typeof returnedValue?.type === "string") throw new Error(`Warning: Middleware for RTK-Query API at reducerPath "${api.reducerPath}" has not been added to the store.
    You must add the middleware for RTK-Query to function correctly!`);
			subscriptionSelectorsRef.current = returnedValue;
		}
		const stableArg = useStableQueryArgs(skip ? skipToken : arg);
		const stableSubscriptionOptions = useShallowStableValue({
			refetchOnReconnect,
			refetchOnFocus,
			pollingInterval,
			skipPollingIfUnfocused
		});
		const initialPageParam = rest.initialPageParam;
		const stableInitialPageParam = useShallowStableValue(initialPageParam);
		const promiseRef = (0, import_react.useRef)(void 0);
		let { queryCacheKey, requestId } = promiseRef.current || {};
		let currentRenderHasSubscription = false;
		if (queryCacheKey && requestId) currentRenderHasSubscription = subscriptionSelectorsRef.current.isRequestSubscribed(queryCacheKey, requestId);
		const subscriptionRemoved = !currentRenderHasSubscription && promiseRef.current !== void 0;
		usePossiblyImmediateEffect(() => {
			if (subscriptionRemoved) promiseRef.current = void 0;
		}, [subscriptionRemoved]);
		usePossiblyImmediateEffect(() => {
			const lastPromise = promiseRef.current;
			if (stableArg === skipToken) {
				lastPromise?.unsubscribe();
				promiseRef.current = void 0;
				return;
			}
			const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;
			if (!lastPromise || lastPromise.arg !== stableArg) {
				lastPromise?.unsubscribe();
				promiseRef.current = dispatch(initiate(stableArg, {
					subscriptionOptions: stableSubscriptionOptions,
					forceRefetch: refetchOnMountOrArgChange,
					...isInfiniteQueryDefinition(context.endpointDefinitions[endpointName]) ? { initialPageParam: stableInitialPageParam } : {}
				}));
			} else if (stableSubscriptionOptions !== lastSubscriptionOptions) lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);
		}, [
			dispatch,
			initiate,
			refetchOnMountOrArgChange,
			stableArg,
			stableSubscriptionOptions,
			subscriptionRemoved,
			stableInitialPageParam,
			endpointName
		]);
		return [
			promiseRef,
			dispatch,
			initiate,
			stableSubscriptionOptions
		];
	}
	function buildUseQueryState(endpointName, preSelector) {
		const useQueryState = (arg, { skip = false, selectFromResult } = {}) => {
			const { select } = api.endpoints[endpointName];
			const stableArg = useStableQueryArgs(skip ? skipToken : arg);
			const lastValue = (0, import_react.useRef)(void 0);
			const selectDefaultResult = (0, import_react.useMemo)(() => createSelector$1([
				select(stableArg),
				(_, lastResult) => lastResult,
				(_) => stableArg
			], preSelector, { memoizeOptions: { resultEqualityCheck: shallowEqual } }), [select, stableArg]);
			const querySelector = (0, import_react.useMemo)(() => selectFromResult ? createSelector$1([selectDefaultResult], selectFromResult, { devModeChecks: { identityFunctionCheck: "never" } }) : selectDefaultResult, [selectDefaultResult, selectFromResult]);
			const currentState = useSelector$1((state) => querySelector(state, lastValue.current), shallowEqual);
			const store = useStore$1();
			const newLastValue = selectDefaultResult(store.getState(), lastValue.current);
			useIsomorphicLayoutEffect(() => {
				lastValue.current = newLastValue;
			}, [newLastValue]);
			return currentState;
		};
		return useQueryState;
	}
	function usePromiseRefUnsubscribeOnUnmount(promiseRef) {
		(0, import_react.useEffect)(() => {
			return () => {
				promiseRef.current?.unsubscribe?.();
				promiseRef.current = void 0;
			};
		}, [promiseRef]);
	}
	function refetchOrErrorIfUnmounted(promiseRef) {
		if (!promiseRef.current) throw new Error("Cannot refetch a query that has not been started yet.");
		return promiseRef.current.refetch();
	}
	function buildQueryHooks(endpointName) {
		const useQuerySubscription = (arg, options = {}) => {
			const [promiseRef] = useQuerySubscriptionCommonImpl(endpointName, arg, options);
			usePromiseRefUnsubscribeOnUnmount(promiseRef);
			return (0, import_react.useMemo)(() => ({ refetch: () => refetchOrErrorIfUnmounted(promiseRef) }), [promiseRef]);
		};
		const useLazyQuerySubscription = ({ refetchOnReconnect, refetchOnFocus, pollingInterval = 0, skipPollingIfUnfocused = false } = {}) => {
			const { initiate } = api.endpoints[endpointName];
			const dispatch = useDispatch$1();
			const [arg, setArg] = (0, import_react.useState)(UNINITIALIZED_VALUE);
			const promiseRef = (0, import_react.useRef)(void 0);
			const stableSubscriptionOptions = useShallowStableValue({
				refetchOnReconnect,
				refetchOnFocus,
				pollingInterval,
				skipPollingIfUnfocused
			});
			usePossiblyImmediateEffect(() => {
				const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;
				if (stableSubscriptionOptions !== lastSubscriptionOptions) promiseRef.current?.updateSubscriptionOptions(stableSubscriptionOptions);
			}, [stableSubscriptionOptions]);
			const subscriptionOptionsRef = (0, import_react.useRef)(stableSubscriptionOptions);
			usePossiblyImmediateEffect(() => {
				subscriptionOptionsRef.current = stableSubscriptionOptions;
			}, [stableSubscriptionOptions]);
			const trigger = (0, import_react.useCallback)(function(arg2, preferCacheValue = false) {
				let promise;
				batch$1(() => {
					promiseRef.current?.unsubscribe();
					promiseRef.current = promise = dispatch(initiate(arg2, {
						subscriptionOptions: subscriptionOptionsRef.current,
						forceRefetch: !preferCacheValue
					}));
					setArg(arg2);
				});
				return promise;
			}, [dispatch, initiate]);
			const reset = (0, import_react.useCallback)(() => {
				if (promiseRef.current?.queryCacheKey) dispatch(api.internalActions.removeQueryResult({ queryCacheKey: promiseRef.current?.queryCacheKey }));
			}, [dispatch]);
			(0, import_react.useEffect)(() => {
				return () => {
					promiseRef?.current?.unsubscribe();
				};
			}, []);
			(0, import_react.useEffect)(() => {
				if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) trigger(arg, true);
			}, [arg, trigger]);
			return (0, import_react.useMemo)(() => [
				trigger,
				arg,
				{ reset }
			], [
				trigger,
				arg,
				reset
			]);
		};
		const useQueryState = buildUseQueryState(endpointName, queryStatePreSelector);
		return {
			useQueryState,
			useQuerySubscription,
			useLazyQuerySubscription,
			useLazyQuery(options) {
				const [trigger, arg, { reset }] = useLazyQuerySubscription(options);
				const queryStateResults = useQueryState(arg, {
					...options,
					skip: arg === UNINITIALIZED_VALUE
				});
				const info = (0, import_react.useMemo)(() => ({ lastArg: arg }), [arg]);
				return (0, import_react.useMemo)(() => [
					trigger,
					{
						...queryStateResults,
						reset
					},
					info
				], [
					trigger,
					queryStateResults,
					reset,
					info
				]);
			},
			useQuery(arg, options) {
				const querySubscriptionResults = useQuerySubscription(arg, options);
				const queryStateResults = useQueryState(arg, {
					selectFromResult: arg === skipToken || options?.skip ? void 0 : noPendingQueryStateSelector,
					...options
				});
				const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS);
				(0, import_react.useDebugValue)(debugValue);
				return (0, import_react.useMemo)(() => ({
					...queryStateResults,
					...querySubscriptionResults
				}), [queryStateResults, querySubscriptionResults]);
			}
		};
	}
	function buildInfiniteQueryHooks(endpointName) {
		const useInfiniteQuerySubscription = (arg, options = {}) => {
			const [promiseRef, dispatch, initiate, stableSubscriptionOptions] = useQuerySubscriptionCommonImpl(endpointName, arg, options);
			const subscriptionOptionsRef = (0, import_react.useRef)(stableSubscriptionOptions);
			usePossiblyImmediateEffect(() => {
				subscriptionOptionsRef.current = stableSubscriptionOptions;
			}, [stableSubscriptionOptions]);
			const trigger = (0, import_react.useCallback)(function(arg2, direction) {
				let promise;
				batch$1(() => {
					promiseRef.current?.unsubscribe();
					promiseRef.current = promise = dispatch(initiate(arg2, {
						subscriptionOptions: subscriptionOptionsRef.current,
						direction
					}));
				});
				return promise;
			}, [
				promiseRef,
				dispatch,
				initiate
			]);
			usePromiseRefUnsubscribeOnUnmount(promiseRef);
			const stableArg = useStableQueryArgs(options.skip ? skipToken : arg);
			const refetch = (0, import_react.useCallback)(() => refetchOrErrorIfUnmounted(promiseRef), [promiseRef]);
			return (0, import_react.useMemo)(() => {
				const fetchNextPage = () => {
					return trigger(stableArg, "forward");
				};
				const fetchPreviousPage = () => {
					return trigger(stableArg, "backward");
				};
				return {
					trigger,
					refetch,
					fetchNextPage,
					fetchPreviousPage
				};
			}, [
				refetch,
				trigger,
				stableArg
			]);
		};
		const useInfiniteQueryState = buildUseQueryState(endpointName, infiniteQueryStatePreSelector);
		return {
			useInfiniteQueryState,
			useInfiniteQuerySubscription,
			useInfiniteQuery(arg, options) {
				const { refetch, fetchNextPage, fetchPreviousPage } = useInfiniteQuerySubscription(arg, options);
				const queryStateResults = useInfiniteQueryState(arg, {
					selectFromResult: arg === skipToken || options?.skip ? void 0 : noPendingQueryStateSelector,
					...options
				});
				const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS, "hasNextPage", "hasPreviousPage");
				(0, import_react.useDebugValue)(debugValue);
				return (0, import_react.useMemo)(() => ({
					...queryStateResults,
					fetchNextPage,
					fetchPreviousPage,
					refetch
				}), [
					queryStateResults,
					fetchNextPage,
					fetchPreviousPage,
					refetch
				]);
			}
		};
	}
	function buildMutationHook(name) {
		return ({ selectFromResult, fixedCacheKey } = {}) => {
			const { select, initiate } = api.endpoints[name];
			const dispatch = useDispatch$1();
			const [promise, setPromise] = (0, import_react.useState)();
			(0, import_react.useEffect)(() => () => {
				if (!promise?.arg.fixedCacheKey) promise?.reset();
			}, [promise]);
			const triggerMutation = (0, import_react.useCallback)(function(arg) {
				const promise2 = dispatch(initiate(arg, { fixedCacheKey }));
				setPromise(promise2);
				return promise2;
			}, [
				dispatch,
				initiate,
				fixedCacheKey
			]);
			const { requestId } = promise || {};
			const selectDefaultResult = (0, import_react.useMemo)(() => select({
				fixedCacheKey,
				requestId: promise?.requestId
			}), [
				fixedCacheKey,
				promise,
				select
			]);
			const mutationSelector = (0, import_react.useMemo)(() => selectFromResult ? createSelector$1([selectDefaultResult], selectFromResult) : selectDefaultResult, [selectFromResult, selectDefaultResult]);
			const currentState = useSelector$1(mutationSelector, shallowEqual);
			const originalArgs = fixedCacheKey == null ? promise?.arg.originalArgs : void 0;
			const reset = (0, import_react.useCallback)(() => {
				batch$1(() => {
					if (promise) setPromise(void 0);
					if (fixedCacheKey) dispatch(api.internalActions.removeMutationResult({
						requestId,
						fixedCacheKey
					}));
				});
			}, [
				dispatch,
				fixedCacheKey,
				promise,
				requestId
			]);
			const debugValue = pick(currentState, ...COMMON_HOOK_DEBUG_FIELDS, "endpointName");
			(0, import_react.useDebugValue)(debugValue);
			const finalState = (0, import_react.useMemo)(() => ({
				...currentState,
				originalArgs,
				reset
			}), [
				currentState,
				originalArgs,
				reset
			]);
			return (0, import_react.useMemo)(() => [triggerMutation, finalState], [triggerMutation, finalState]);
		};
	}
}
var reactHooksModuleName = /* @__PURE__ */ Symbol();
var reactHooksModule = ({ batch: batch$1 = batch, hooks = {
	useDispatch,
	useSelector,
	useStore
}, createSelector: createSelector$1 = createSelector, unstable__sideEffectsInRender = false,...rest } = {}) => {
	{
		const hookNames = [
			"useDispatch",
			"useSelector",
			"useStore"
		];
		let warned = false;
		for (const hookName of hookNames) {
			if (countObjectKeys(rest) > 0) {
				if (rest[hookName]) {
					if (!warned) {
						console.warn("As of RTK 2.0, the hooks now need to be specified as one object, provided under a `hooks` key:\n`reactHooksModule({ hooks: { useDispatch, useSelector, useStore } })`");
						warned = true;
					}
				}
				hooks[hookName] = rest[hookName];
			}
			if (typeof hooks[hookName] !== "function") throw new Error(`When using custom hooks for context, all ${hookNames.length} hooks need to be provided: ${hookNames.join(", ")}.
Hook ${hookName} was either not provided or not a function.`);
		}
	}
	return {
		name: reactHooksModuleName,
		init(api, { serializeQueryArgs }, context) {
			const anyApi = api;
			const { buildQueryHooks, buildInfiniteQueryHooks, buildMutationHook, usePrefetch } = buildHooks({
				api,
				moduleOptions: {
					batch: batch$1,
					hooks,
					unstable__sideEffectsInRender,
					createSelector: createSelector$1
				},
				serializeQueryArgs,
				context
			});
			safeAssign(anyApi, { usePrefetch });
			safeAssign(context, { batch: batch$1 });
			return { injectEndpoint(endpointName, definition) {
				if (isQueryDefinition(definition)) {
					const { useQuery, useLazyQuery, useLazyQuerySubscription, useQueryState, useQuerySubscription } = buildQueryHooks(endpointName);
					safeAssign(anyApi.endpoints[endpointName], {
						useQuery,
						useLazyQuery,
						useLazyQuerySubscription,
						useQueryState,
						useQuerySubscription
					});
					api[`use${capitalize(endpointName)}Query`] = useQuery;
					api[`useLazy${capitalize(endpointName)}Query`] = useLazyQuery;
				}
				if (isMutationDefinition(definition)) {
					const useMutation = buildMutationHook(endpointName);
					safeAssign(anyApi.endpoints[endpointName], { useMutation });
					api[`use${capitalize(endpointName)}Mutation`] = useMutation;
				} else if (isInfiniteQueryDefinition(definition)) {
					const { useInfiniteQuery, useInfiniteQuerySubscription, useInfiniteQueryState } = buildInfiniteQueryHooks(endpointName);
					safeAssign(anyApi.endpoints[endpointName], {
						useInfiniteQuery,
						useInfiniteQuerySubscription,
						useInfiniteQueryState
					});
					api[`use${capitalize(endpointName)}InfiniteQuery`] = useInfiniteQuery;
				}
			} };
		}
	};
};
function ApiProvider(props) {
	const context = props.context || ReactReduxContext;
	if ((0, import_react.useContext)(context)) throw new Error("Existing Redux context detected. If you already have a store set up, please use the traditional Redux setup.");
	const [store] = import_react.useState(() => configureStore({
		reducer: { [props.api.reducerPath]: props.api.reducer },
		middleware: (gDM) => gDM().concat(props.api.middleware)
	}));
	(0, import_react.useEffect)(() => props.setupListeners === false ? void 0 : setupListeners(store.dispatch, props.setupListeners), [props.setupListeners, store.dispatch]);
	return /* @__PURE__ */ import_react.createElement(Provider_default, {
		store,
		context
	}, props.children);
}
var createApi = /* @__PURE__ */ buildCreateApi(coreModule(), reactHooksModule());

//#endregion
export { ApiProvider, NamedSchemaError, QueryStatus, UNINITIALIZED_VALUE, _NEVER, buildCreateApi, copyWithStructuralSharing, coreModule, coreModuleName, createApi, defaultSerializeQueryArgs, fakeBaseQuery, fetchBaseQuery, reactHooksModule, reactHooksModuleName, retry, setupListeners, skipToken };
//# sourceMappingURL=@reduxjs_toolkit_query_react.js.map