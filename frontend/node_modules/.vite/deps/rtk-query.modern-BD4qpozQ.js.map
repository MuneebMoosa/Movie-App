{"version":3,"file":"rtk-query.modern-BD4qpozQ.js","names":["createNextState","produceWithPatches2"],"sources":["../../@standard-schema/utils/dist/index.js","../../@reduxjs/toolkit/dist/query/rtk-query.modern.mjs"],"sourcesContent":["// src/getDotPath/getDotPath.ts\nfunction getDotPath(issue) {\n  if (issue.path?.length) {\n    let dotPath = \"\";\n    for (const item of issue.path) {\n      const key = typeof item === \"object\" ? item.key : item;\n      if (typeof key === \"string\" || typeof key === \"number\") {\n        if (dotPath) {\n          dotPath += `.${key}`;\n        } else {\n          dotPath += key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return dotPath;\n  }\n  return null;\n}\n\n// src/SchemaError/SchemaError.ts\nvar SchemaError = class extends Error {\n  /**\n   * The schema issues.\n   */\n  issues;\n  /**\n   * Creates a schema error with useful information.\n   *\n   * @param issues The schema issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"SchemaError\";\n    this.issues = issues;\n  }\n};\nexport {\n  SchemaError,\n  getDotPath\n};\n","// src/query/core/apiState.ts\nvar QueryStatus = /* @__PURE__ */ ((QueryStatus2) => {\n  QueryStatus2[\"uninitialized\"] = \"uninitialized\";\n  QueryStatus2[\"pending\"] = \"pending\";\n  QueryStatus2[\"fulfilled\"] = \"fulfilled\";\n  QueryStatus2[\"rejected\"] = \"rejected\";\n  return QueryStatus2;\n})(QueryStatus || {});\nfunction getRequestStatusFlags(status) {\n  return {\n    status,\n    isUninitialized: status === \"uninitialized\" /* uninitialized */,\n    isLoading: status === \"pending\" /* pending */,\n    isSuccess: status === \"fulfilled\" /* fulfilled */,\n    isError: status === \"rejected\" /* rejected */\n  };\n}\n\n// src/query/core/rtkImports.ts\nimport { createAction, createSlice, createSelector, createAsyncThunk, combineReducers, createNextState, isAnyOf, isAllOf, isAction, isPending, isRejected, isFulfilled, isRejectedWithValue, isAsyncThunkAction, prepareAutoBatched, SHOULD_AUTOBATCH, isPlainObject, nanoid } from \"@reduxjs/toolkit\";\n\n// src/query/utils/copyWithStructuralSharing.ts\nvar isPlainObject2 = isPlainObject;\nfunction copyWithStructuralSharing(oldObj, newObj) {\n  if (oldObj === newObj || !(isPlainObject2(oldObj) && isPlainObject2(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {\n    return newObj;\n  }\n  const newKeys = Object.keys(newObj);\n  const oldKeys = Object.keys(oldObj);\n  let isSameObject = newKeys.length === oldKeys.length;\n  const mergeObj = Array.isArray(newObj) ? [] : {};\n  for (const key of newKeys) {\n    mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);\n    if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];\n  }\n  return isSameObject ? oldObj : mergeObj;\n}\n\n// src/query/utils/flatten.ts\nvar flatten = (arr) => [].concat(...arr);\n\n// src/query/utils/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return new RegExp(`(^|:)//`).test(url);\n}\n\n// src/query/utils/isDocumentVisible.ts\nfunction isDocumentVisible() {\n  if (typeof document === \"undefined\") {\n    return true;\n  }\n  return document.visibilityState !== \"hidden\";\n}\n\n// src/query/utils/isNotNullish.ts\nfunction isNotNullish(v) {\n  return v != null;\n}\nfunction filterNullishValues(map) {\n  return [...map?.values() ?? []].filter(isNotNullish);\n}\n\n// src/query/utils/isOnline.ts\nfunction isOnline() {\n  return typeof navigator === \"undefined\" ? true : navigator.onLine === void 0 ? true : navigator.onLine;\n}\n\n// src/query/utils/joinUrls.ts\nvar withoutTrailingSlash = (url) => url.replace(/\\/$/, \"\");\nvar withoutLeadingSlash = (url) => url.replace(/^\\//, \"\");\nfunction joinUrls(base, url) {\n  if (!base) {\n    return url;\n  }\n  if (!url) {\n    return base;\n  }\n  if (isAbsoluteUrl(url)) {\n    return url;\n  }\n  const delimiter = base.endsWith(\"/\") || !url.startsWith(\"?\") ? \"/\" : \"\";\n  base = withoutTrailingSlash(base);\n  url = withoutLeadingSlash(url);\n  return `${base}${delimiter}${url}`;\n}\n\n// src/query/utils/getOrInsert.ts\nfunction getOrInsertComputed(map, key, compute) {\n  if (map.has(key)) return map.get(key);\n  return map.set(key, compute(key)).get(key);\n}\nvar createNewMap = () => /* @__PURE__ */ new Map();\n\n// src/query/fetchBaseQuery.ts\nvar defaultFetchFn = (...args) => fetch(...args);\nvar defaultValidateStatus = (response) => response.status >= 200 && response.status <= 299;\nvar defaultIsJsonContentType = (headers) => (\n  /*applicat*/\n  /ion\\/(vnd\\.api\\+)?json/.test(headers.get(\"content-type\") || \"\")\n);\nfunction stripUndefined(obj) {\n  if (!isPlainObject(obj)) {\n    return obj;\n  }\n  const copy = {\n    ...obj\n  };\n  for (const [k, v] of Object.entries(copy)) {\n    if (v === void 0) delete copy[k];\n  }\n  return copy;\n}\nvar isJsonifiable = (body) => typeof body === \"object\" && (isPlainObject(body) || Array.isArray(body) || typeof body.toJSON === \"function\");\nfunction fetchBaseQuery({\n  baseUrl,\n  prepareHeaders = (x) => x,\n  fetchFn = defaultFetchFn,\n  paramsSerializer,\n  isJsonContentType = defaultIsJsonContentType,\n  jsonContentType = \"application/json\",\n  jsonReplacer,\n  timeout: defaultTimeout,\n  responseHandler: globalResponseHandler,\n  validateStatus: globalValidateStatus,\n  ...baseFetchOptions\n} = {}) {\n  if (typeof fetch === \"undefined\" && fetchFn === defaultFetchFn) {\n    console.warn(\"Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.\");\n  }\n  return async (arg, api, extraOptions) => {\n    const {\n      getState,\n      extra,\n      endpoint,\n      forced,\n      type\n    } = api;\n    let meta;\n    let {\n      url,\n      headers = new Headers(baseFetchOptions.headers),\n      params = void 0,\n      responseHandler = globalResponseHandler ?? \"json\",\n      validateStatus = globalValidateStatus ?? defaultValidateStatus,\n      timeout = defaultTimeout,\n      ...rest\n    } = typeof arg == \"string\" ? {\n      url: arg\n    } : arg;\n    let abortController, signal = api.signal;\n    if (timeout) {\n      abortController = new AbortController();\n      api.signal.addEventListener(\"abort\", abortController.abort);\n      signal = abortController.signal;\n    }\n    let config = {\n      ...baseFetchOptions,\n      signal,\n      ...rest\n    };\n    headers = new Headers(stripUndefined(headers));\n    config.headers = await prepareHeaders(headers, {\n      getState,\n      arg,\n      extra,\n      endpoint,\n      forced,\n      type,\n      extraOptions\n    }) || headers;\n    const bodyIsJsonifiable = isJsonifiable(config.body);\n    if (config.body != null && !bodyIsJsonifiable && typeof config.body !== \"string\") {\n      config.headers.delete(\"content-type\");\n    }\n    if (!config.headers.has(\"content-type\") && bodyIsJsonifiable) {\n      config.headers.set(\"content-type\", jsonContentType);\n    }\n    if (bodyIsJsonifiable && isJsonContentType(config.headers)) {\n      config.body = JSON.stringify(config.body, jsonReplacer);\n    }\n    if (!config.headers.has(\"accept\")) {\n      if (responseHandler === \"json\") {\n        config.headers.set(\"accept\", \"application/json\");\n      } else if (responseHandler === \"text\") {\n        config.headers.set(\"accept\", \"text/plain, text/html, */*\");\n      }\n    }\n    if (params) {\n      const divider = ~url.indexOf(\"?\") ? \"&\" : \"?\";\n      const query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));\n      url += divider + query;\n    }\n    url = joinUrls(baseUrl, url);\n    const request = new Request(url, config);\n    const requestClone = new Request(url, config);\n    meta = {\n      request: requestClone\n    };\n    let response, timedOut = false, timeoutId = abortController && setTimeout(() => {\n      timedOut = true;\n      abortController.abort();\n    }, timeout);\n    try {\n      response = await fetchFn(request);\n    } catch (e) {\n      return {\n        error: {\n          status: timedOut ? \"TIMEOUT_ERROR\" : \"FETCH_ERROR\",\n          error: String(e)\n        },\n        meta\n      };\n    } finally {\n      if (timeoutId) clearTimeout(timeoutId);\n      abortController?.signal.removeEventListener(\"abort\", abortController.abort);\n    }\n    const responseClone = response.clone();\n    meta.response = responseClone;\n    let resultData;\n    let responseText = \"\";\n    try {\n      let handleResponseError;\n      await Promise.all([\n        handleResponse(response, responseHandler).then((r) => resultData = r, (e) => handleResponseError = e),\n        // see https://github.com/node-fetch/node-fetch/issues/665#issuecomment-538995182\n        // we *have* to \"use up\" both streams at the same time or they will stop running in node-fetch scenarios\n        responseClone.text().then((r) => responseText = r, () => {\n        })\n      ]);\n      if (handleResponseError) throw handleResponseError;\n    } catch (e) {\n      return {\n        error: {\n          status: \"PARSING_ERROR\",\n          originalStatus: response.status,\n          data: responseText,\n          error: String(e)\n        },\n        meta\n      };\n    }\n    return validateStatus(response, resultData) ? {\n      data: resultData,\n      meta\n    } : {\n      error: {\n        status: response.status,\n        data: resultData\n      },\n      meta\n    };\n  };\n  async function handleResponse(response, responseHandler) {\n    if (typeof responseHandler === \"function\") {\n      return responseHandler(response);\n    }\n    if (responseHandler === \"content-type\") {\n      responseHandler = isJsonContentType(response.headers) ? \"json\" : \"text\";\n    }\n    if (responseHandler === \"json\") {\n      const text = await response.text();\n      return text.length ? JSON.parse(text) : null;\n    }\n    return response.text();\n  }\n}\n\n// src/query/HandledError.ts\nvar HandledError = class {\n  constructor(value, meta = void 0) {\n    this.value = value;\n    this.meta = meta;\n  }\n};\n\n// src/query/retry.ts\nasync function defaultBackoff(attempt = 0, maxRetries = 5, signal) {\n  const attempts = Math.min(attempt, maxRetries);\n  const timeout = ~~((Math.random() + 0.4) * (300 << attempts));\n  await new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => resolve(), timeout);\n    if (signal) {\n      const abortHandler = () => {\n        clearTimeout(timeoutId);\n        reject(new Error(\"Aborted\"));\n      };\n      if (signal.aborted) {\n        clearTimeout(timeoutId);\n        reject(new Error(\"Aborted\"));\n      } else {\n        signal.addEventListener(\"abort\", abortHandler, {\n          once: true\n        });\n      }\n    }\n  });\n}\nfunction fail(error, meta) {\n  throw Object.assign(new HandledError({\n    error,\n    meta\n  }), {\n    throwImmediately: true\n  });\n}\nfunction failIfAborted(signal) {\n  if (signal.aborted) {\n    fail({\n      status: \"CUSTOM_ERROR\",\n      error: \"Aborted\"\n    });\n  }\n}\nvar EMPTY_OPTIONS = {};\nvar retryWithBackoff = (baseQuery, defaultOptions) => async (args, api, extraOptions) => {\n  const possibleMaxRetries = [5, (defaultOptions || EMPTY_OPTIONS).maxRetries, (extraOptions || EMPTY_OPTIONS).maxRetries].filter((x) => x !== void 0);\n  const [maxRetries] = possibleMaxRetries.slice(-1);\n  const defaultRetryCondition = (_, __, {\n    attempt\n  }) => attempt <= maxRetries;\n  const options = {\n    maxRetries,\n    backoff: defaultBackoff,\n    retryCondition: defaultRetryCondition,\n    ...defaultOptions,\n    ...extraOptions\n  };\n  let retry2 = 0;\n  while (true) {\n    failIfAborted(api.signal);\n    try {\n      const result = await baseQuery(args, api, extraOptions);\n      if (result.error) {\n        throw new HandledError(result);\n      }\n      return result;\n    } catch (e) {\n      retry2++;\n      if (e.throwImmediately) {\n        if (e instanceof HandledError) {\n          return e.value;\n        }\n        throw e;\n      }\n      if (e instanceof HandledError) {\n        if (!options.retryCondition(e.value.error, args, {\n          attempt: retry2,\n          baseQueryApi: api,\n          extraOptions\n        })) {\n          return e.value;\n        }\n      } else {\n        if (retry2 > options.maxRetries) {\n          return {\n            error: e\n          };\n        }\n      }\n      failIfAborted(api.signal);\n      try {\n        await options.backoff(retry2, options.maxRetries, api.signal);\n      } catch (backoffError) {\n        failIfAborted(api.signal);\n        throw backoffError;\n      }\n    }\n  }\n};\nvar retry = /* @__PURE__ */ Object.assign(retryWithBackoff, {\n  fail\n});\n\n// src/query/core/setupListeners.ts\nvar onFocus = /* @__PURE__ */ createAction(\"__rtkq/focused\");\nvar onFocusLost = /* @__PURE__ */ createAction(\"__rtkq/unfocused\");\nvar onOnline = /* @__PURE__ */ createAction(\"__rtkq/online\");\nvar onOffline = /* @__PURE__ */ createAction(\"__rtkq/offline\");\nvar initialized = false;\nfunction setupListeners(dispatch, customHandler) {\n  function defaultHandler() {\n    const handleFocus = () => dispatch(onFocus());\n    const handleFocusLost = () => dispatch(onFocusLost());\n    const handleOnline = () => dispatch(onOnline());\n    const handleOffline = () => dispatch(onOffline());\n    const handleVisibilityChange = () => {\n      if (window.document.visibilityState === \"visible\") {\n        handleFocus();\n      } else {\n        handleFocusLost();\n      }\n    };\n    if (!initialized) {\n      if (typeof window !== \"undefined\" && window.addEventListener) {\n        window.addEventListener(\"visibilitychange\", handleVisibilityChange, false);\n        window.addEventListener(\"focus\", handleFocus, false);\n        window.addEventListener(\"online\", handleOnline, false);\n        window.addEventListener(\"offline\", handleOffline, false);\n        initialized = true;\n      }\n    }\n    const unsubscribe = () => {\n      window.removeEventListener(\"focus\", handleFocus);\n      window.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n      initialized = false;\n    };\n    return unsubscribe;\n  }\n  return customHandler ? customHandler(dispatch, {\n    onFocus,\n    onFocusLost,\n    onOffline,\n    onOnline\n  }) : defaultHandler();\n}\n\n// src/query/endpointDefinitions.ts\nfunction isQueryDefinition(e) {\n  return e.type === \"query\" /* query */;\n}\nfunction isMutationDefinition(e) {\n  return e.type === \"mutation\" /* mutation */;\n}\nfunction isInfiniteQueryDefinition(e) {\n  return e.type === \"infinitequery\" /* infinitequery */;\n}\nfunction isAnyQueryDefinition(e) {\n  return isQueryDefinition(e) || isInfiniteQueryDefinition(e);\n}\nfunction calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {\n  if (isFunction(description)) {\n    return description(result, error, queryArg, meta).filter(isNotNullish).map(expandTagDescription).map(assertTagTypes);\n  }\n  if (Array.isArray(description)) {\n    return description.map(expandTagDescription).map(assertTagTypes);\n  }\n  return [];\n}\nfunction isFunction(t) {\n  return typeof t === \"function\";\n}\nfunction expandTagDescription(description) {\n  return typeof description === \"string\" ? {\n    type: description\n  } : description;\n}\n\n// src/query/core/buildThunks.ts\nimport { isDraftable, produceWithPatches } from \"immer\";\n\n// src/query/core/buildInitiate.ts\nimport { formatProdErrorMessage as _formatProdErrorMessage } from \"@reduxjs/toolkit\";\n\n// src/tsHelpers.ts\nfunction asSafePromise(promise, fallback) {\n  return promise.catch(fallback);\n}\n\n// src/query/core/buildInitiate.ts\nvar forceQueryFnSymbol = Symbol(\"forceQueryFn\");\nvar isUpsertQuery = (arg) => typeof arg[forceQueryFnSymbol] === \"function\";\nfunction buildInitiate({\n  serializeQueryArgs,\n  queryThunk,\n  infiniteQueryThunk,\n  mutationThunk,\n  api,\n  context,\n  getInternalState\n}) {\n  const getRunningQueries = (dispatch) => getInternalState(dispatch)?.runningQueries;\n  const getRunningMutations = (dispatch) => getInternalState(dispatch)?.runningMutations;\n  const {\n    unsubscribeQueryResult,\n    removeMutationResult,\n    updateSubscriptionOptions\n  } = api.internalActions;\n  return {\n    buildInitiateQuery,\n    buildInitiateInfiniteQuery,\n    buildInitiateMutation,\n    getRunningQueryThunk,\n    getRunningMutationThunk,\n    getRunningQueriesThunk,\n    getRunningMutationsThunk\n  };\n  function getRunningQueryThunk(endpointName, queryArgs) {\n    return (dispatch) => {\n      const endpointDefinition = context.endpointDefinitions[endpointName];\n      const queryCacheKey = serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      });\n      return getRunningQueries(dispatch)?.get(queryCacheKey);\n    };\n  }\n  function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {\n    return (dispatch) => {\n      return getRunningMutations(dispatch)?.get(fixedCacheKeyOrRequestId);\n    };\n  }\n  function getRunningQueriesThunk() {\n    return (dispatch) => filterNullishValues(getRunningQueries(dispatch));\n  }\n  function getRunningMutationsThunk() {\n    return (dispatch) => filterNullishValues(getRunningMutations(dispatch));\n  }\n  function middlewareWarning(dispatch) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (middlewareWarning.triggered) return;\n      const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());\n      middlewareWarning.triggered = true;\n      if (typeof returnedValue !== \"object\" || typeof returnedValue?.type === \"string\") {\n        throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage(34) : `Warning: Middleware for RTK-Query API at reducerPath \"${api.reducerPath}\" has not been added to the store.\nYou must add the middleware for RTK-Query to function correctly!`);\n      }\n    }\n  }\n  function buildInitiateAnyQuery(endpointName, endpointDefinition) {\n    const queryAction = (arg, {\n      subscribe = true,\n      forceRefetch,\n      subscriptionOptions,\n      [forceQueryFnSymbol]: forceQueryFn,\n      ...rest\n    } = {}) => (dispatch, getState) => {\n      const queryCacheKey = serializeQueryArgs({\n        queryArgs: arg,\n        endpointDefinition,\n        endpointName\n      });\n      let thunk;\n      const commonThunkArgs = {\n        ...rest,\n        type: \"query\",\n        subscribe,\n        forceRefetch,\n        subscriptionOptions,\n        endpointName,\n        originalArgs: arg,\n        queryCacheKey,\n        [forceQueryFnSymbol]: forceQueryFn\n      };\n      if (isQueryDefinition(endpointDefinition)) {\n        thunk = queryThunk(commonThunkArgs);\n      } else {\n        const {\n          direction,\n          initialPageParam\n        } = rest;\n        thunk = infiniteQueryThunk({\n          ...commonThunkArgs,\n          // Supply these even if undefined. This helps with a field existence\n          // check over in `buildSlice.ts`\n          direction,\n          initialPageParam\n        });\n      }\n      const selector = api.endpoints[endpointName].select(arg);\n      const thunkResult = dispatch(thunk);\n      const stateAfter = selector(getState());\n      middlewareWarning(dispatch);\n      const {\n        requestId,\n        abort\n      } = thunkResult;\n      const skippedSynchronously = stateAfter.requestId !== requestId;\n      const runningQuery = getRunningQueries(dispatch)?.get(queryCacheKey);\n      const selectFromState = () => selector(getState());\n      const statePromise = Object.assign(forceQueryFn ? (\n        // a query has been forced (upsertQueryData)\n        // -> we want to resolve it once data has been written with the data that will be written\n        thunkResult.then(selectFromState)\n      ) : skippedSynchronously && !runningQuery ? (\n        // a query has been skipped due to a condition and we do not have any currently running query\n        // -> we want to resolve it immediately with the current data\n        Promise.resolve(stateAfter)\n      ) : (\n        // query just started or one is already in flight\n        // -> wait for the running query, then resolve with data from after that\n        Promise.all([runningQuery, thunkResult]).then(selectFromState)\n      ), {\n        arg,\n        requestId,\n        subscriptionOptions,\n        queryCacheKey,\n        abort,\n        async unwrap() {\n          const result = await statePromise;\n          if (result.isError) {\n            throw result.error;\n          }\n          return result.data;\n        },\n        refetch: () => dispatch(queryAction(arg, {\n          subscribe: false,\n          forceRefetch: true\n        })),\n        unsubscribe() {\n          if (subscribe) dispatch(unsubscribeQueryResult({\n            queryCacheKey,\n            requestId\n          }));\n        },\n        updateSubscriptionOptions(options) {\n          statePromise.subscriptionOptions = options;\n          dispatch(updateSubscriptionOptions({\n            endpointName,\n            requestId,\n            queryCacheKey,\n            options\n          }));\n        }\n      });\n      if (!runningQuery && !skippedSynchronously && !forceQueryFn) {\n        const runningQueries = getRunningQueries(dispatch);\n        runningQueries.set(queryCacheKey, statePromise);\n        statePromise.then(() => {\n          runningQueries.delete(queryCacheKey);\n        });\n      }\n      return statePromise;\n    };\n    return queryAction;\n  }\n  function buildInitiateQuery(endpointName, endpointDefinition) {\n    const queryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);\n    return queryAction;\n  }\n  function buildInitiateInfiniteQuery(endpointName, endpointDefinition) {\n    const infiniteQueryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);\n    return infiniteQueryAction;\n  }\n  function buildInitiateMutation(endpointName) {\n    return (arg, {\n      track = true,\n      fixedCacheKey\n    } = {}) => (dispatch, getState) => {\n      const thunk = mutationThunk({\n        type: \"mutation\",\n        endpointName,\n        originalArgs: arg,\n        track,\n        fixedCacheKey\n      });\n      const thunkResult = dispatch(thunk);\n      middlewareWarning(dispatch);\n      const {\n        requestId,\n        abort,\n        unwrap\n      } = thunkResult;\n      const returnValuePromise = asSafePromise(thunkResult.unwrap().then((data) => ({\n        data\n      })), (error) => ({\n        error\n      }));\n      const reset = () => {\n        dispatch(removeMutationResult({\n          requestId,\n          fixedCacheKey\n        }));\n      };\n      const ret = Object.assign(returnValuePromise, {\n        arg: thunkResult.arg,\n        requestId,\n        abort,\n        unwrap,\n        reset\n      });\n      const runningMutations = getRunningMutations(dispatch);\n      runningMutations.set(requestId, ret);\n      ret.then(() => {\n        runningMutations.delete(requestId);\n      });\n      if (fixedCacheKey) {\n        runningMutations.set(fixedCacheKey, ret);\n        ret.then(() => {\n          if (runningMutations.get(fixedCacheKey) === ret) {\n            runningMutations.delete(fixedCacheKey);\n          }\n        });\n      }\n      return ret;\n    };\n  }\n}\n\n// src/query/standardSchema.ts\nimport { SchemaError } from \"@standard-schema/utils\";\nvar NamedSchemaError = class extends SchemaError {\n  constructor(issues, value, schemaName, _bqMeta) {\n    super(issues);\n    this.value = value;\n    this.schemaName = schemaName;\n    this._bqMeta = _bqMeta;\n  }\n};\nvar shouldSkip = (skipSchemaValidation, schemaName) => Array.isArray(skipSchemaValidation) ? skipSchemaValidation.includes(schemaName) : !!skipSchemaValidation;\nasync function parseWithSchema(schema, data, schemaName, bqMeta) {\n  const result = await schema[\"~standard\"].validate(data);\n  if (result.issues) {\n    throw new NamedSchemaError(result.issues, data, schemaName, bqMeta);\n  }\n  return result.value;\n}\n\n// src/query/core/buildThunks.ts\nfunction defaultTransformResponse(baseQueryReturnValue) {\n  return baseQueryReturnValue;\n}\nvar addShouldAutoBatch = (arg = {}) => {\n  return {\n    ...arg,\n    [SHOULD_AUTOBATCH]: true\n  };\n};\nfunction buildThunks({\n  reducerPath,\n  baseQuery,\n  context: {\n    endpointDefinitions\n  },\n  serializeQueryArgs,\n  api,\n  assertTagType,\n  selectors,\n  onSchemaFailure,\n  catchSchemaFailure: globalCatchSchemaFailure,\n  skipSchemaValidation: globalSkipSchemaValidation\n}) {\n  const patchQueryData = (endpointName, arg, patches, updateProvided) => (dispatch, getState) => {\n    const endpointDefinition = endpointDefinitions[endpointName];\n    const queryCacheKey = serializeQueryArgs({\n      queryArgs: arg,\n      endpointDefinition,\n      endpointName\n    });\n    dispatch(api.internalActions.queryResultPatched({\n      queryCacheKey,\n      patches\n    }));\n    if (!updateProvided) {\n      return;\n    }\n    const newValue = api.endpoints[endpointName].select(arg)(\n      // Work around TS 4.1 mismatch\n      getState()\n    );\n    const providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, arg, {}, assertTagType);\n    dispatch(api.internalActions.updateProvidedBy([{\n      queryCacheKey,\n      providedTags\n    }]));\n  };\n  function addToStart(items, item, max = 0) {\n    const newItems = [item, ...items];\n    return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n  }\n  function addToEnd(items, item, max = 0) {\n    const newItems = [...items, item];\n    return max && newItems.length > max ? newItems.slice(1) : newItems;\n  }\n  const updateQueryData = (endpointName, arg, updateRecipe, updateProvided = true) => (dispatch, getState) => {\n    const endpointDefinition = api.endpoints[endpointName];\n    const currentState = endpointDefinition.select(arg)(\n      // Work around TS 4.1 mismatch\n      getState()\n    );\n    const ret = {\n      patches: [],\n      inversePatches: [],\n      undo: () => dispatch(api.util.patchQueryData(endpointName, arg, ret.inversePatches, updateProvided))\n    };\n    if (currentState.status === \"uninitialized\" /* uninitialized */) {\n      return ret;\n    }\n    let newValue;\n    if (\"data\" in currentState) {\n      if (isDraftable(currentState.data)) {\n        const [value, patches, inversePatches] = produceWithPatches(currentState.data, updateRecipe);\n        ret.patches.push(...patches);\n        ret.inversePatches.push(...inversePatches);\n        newValue = value;\n      } else {\n        newValue = updateRecipe(currentState.data);\n        ret.patches.push({\n          op: \"replace\",\n          path: [],\n          value: newValue\n        });\n        ret.inversePatches.push({\n          op: \"replace\",\n          path: [],\n          value: currentState.data\n        });\n      }\n    }\n    if (ret.patches.length === 0) {\n      return ret;\n    }\n    dispatch(api.util.patchQueryData(endpointName, arg, ret.patches, updateProvided));\n    return ret;\n  };\n  const upsertQueryData = (endpointName, arg, value) => (dispatch) => {\n    const res = dispatch(api.endpoints[endpointName].initiate(arg, {\n      subscribe: false,\n      forceRefetch: true,\n      [forceQueryFnSymbol]: () => ({\n        data: value\n      })\n    }));\n    return res;\n  };\n  const getTransformCallbackForEndpoint = (endpointDefinition, transformFieldName) => {\n    return endpointDefinition.query && endpointDefinition[transformFieldName] ? endpointDefinition[transformFieldName] : defaultTransformResponse;\n  };\n  const executeEndpoint = async (arg, {\n    signal,\n    abort,\n    rejectWithValue,\n    fulfillWithValue,\n    dispatch,\n    getState,\n    extra\n  }) => {\n    const endpointDefinition = endpointDefinitions[arg.endpointName];\n    const {\n      metaSchema,\n      skipSchemaValidation = globalSkipSchemaValidation\n    } = endpointDefinition;\n    try {\n      let transformResponse = defaultTransformResponse;\n      const baseQueryApi = {\n        signal,\n        abort,\n        dispatch,\n        getState,\n        extra,\n        endpoint: arg.endpointName,\n        type: arg.type,\n        forced: arg.type === \"query\" ? isForcedQuery(arg, getState()) : void 0,\n        queryCacheKey: arg.type === \"query\" ? arg.queryCacheKey : void 0\n      };\n      const forceQueryFn = arg.type === \"query\" ? arg[forceQueryFnSymbol] : void 0;\n      let finalQueryReturnValue;\n      const fetchPage = async (data, param, maxPages, previous) => {\n        if (param == null && data.pages.length) {\n          return Promise.resolve({\n            data\n          });\n        }\n        const finalQueryArg = {\n          queryArg: arg.originalArgs,\n          pageParam: param\n        };\n        const pageResponse = await executeRequest(finalQueryArg);\n        const addTo = previous ? addToStart : addToEnd;\n        return {\n          data: {\n            pages: addTo(data.pages, pageResponse.data, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          },\n          meta: pageResponse.meta\n        };\n      };\n      async function executeRequest(finalQueryArg) {\n        let result;\n        const {\n          extraOptions,\n          argSchema,\n          rawResponseSchema,\n          responseSchema\n        } = endpointDefinition;\n        if (argSchema && !shouldSkip(skipSchemaValidation, \"arg\")) {\n          finalQueryArg = await parseWithSchema(\n            argSchema,\n            finalQueryArg,\n            \"argSchema\",\n            {}\n            // we don't have a meta yet, so we can't pass it\n          );\n        }\n        if (forceQueryFn) {\n          result = forceQueryFn();\n        } else if (endpointDefinition.query) {\n          transformResponse = getTransformCallbackForEndpoint(endpointDefinition, \"transformResponse\");\n          result = await baseQuery(endpointDefinition.query(finalQueryArg), baseQueryApi, extraOptions);\n        } else {\n          result = await endpointDefinition.queryFn(finalQueryArg, baseQueryApi, extraOptions, (arg2) => baseQuery(arg2, baseQueryApi, extraOptions));\n        }\n        if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n          const what = endpointDefinition.query ? \"`baseQuery`\" : \"`queryFn`\";\n          let err;\n          if (!result) {\n            err = `${what} did not return anything.`;\n          } else if (typeof result !== \"object\") {\n            err = `${what} did not return an object.`;\n          } else if (result.error && result.data) {\n            err = `${what} returned an object containing both \\`error\\` and \\`result\\`.`;\n          } else if (result.error === void 0 && result.data === void 0) {\n            err = `${what} returned an object containing neither a valid \\`error\\` and \\`result\\`. At least one of them should not be \\`undefined\\``;\n          } else {\n            for (const key of Object.keys(result)) {\n              if (key !== \"error\" && key !== \"data\" && key !== \"meta\") {\n                err = `The object returned by ${what} has the unknown property ${key}.`;\n                break;\n              }\n            }\n          }\n          if (err) {\n            console.error(`Error encountered handling the endpoint ${arg.endpointName}.\n                  ${err}\n                  It needs to return an object with either the shape \\`{ data: <value> }\\` or \\`{ error: <value> }\\` that may contain an optional \\`meta\\` property.\n                  Object returned was:`, result);\n          }\n        }\n        if (result.error) throw new HandledError(result.error, result.meta);\n        let {\n          data\n        } = result;\n        if (rawResponseSchema && !shouldSkip(skipSchemaValidation, \"rawResponse\")) {\n          data = await parseWithSchema(rawResponseSchema, result.data, \"rawResponseSchema\", result.meta);\n        }\n        let transformedResponse = await transformResponse(data, result.meta, finalQueryArg);\n        if (responseSchema && !shouldSkip(skipSchemaValidation, \"response\")) {\n          transformedResponse = await parseWithSchema(responseSchema, transformedResponse, \"responseSchema\", result.meta);\n        }\n        return {\n          ...result,\n          data: transformedResponse\n        };\n      }\n      if (arg.type === \"query\" && \"infiniteQueryOptions\" in endpointDefinition) {\n        const {\n          infiniteQueryOptions\n        } = endpointDefinition;\n        const {\n          maxPages = Infinity\n        } = infiniteQueryOptions;\n        let result;\n        const blankData = {\n          pages: [],\n          pageParams: []\n        };\n        const cachedData = selectors.selectQueryEntry(getState(), arg.queryCacheKey)?.data;\n        const isForcedQueryNeedingRefetch = (\n          // arg.forceRefetch\n          isForcedQuery(arg, getState()) && !arg.direction\n        );\n        const existingData = isForcedQueryNeedingRefetch || !cachedData ? blankData : cachedData;\n        if (\"direction\" in arg && arg.direction && existingData.pages.length) {\n          const previous = arg.direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const param = pageParamFn(infiniteQueryOptions, existingData, arg.originalArgs);\n          result = await fetchPage(existingData, param, maxPages, previous);\n        } else {\n          const {\n            initialPageParam = infiniteQueryOptions.initialPageParam\n          } = arg;\n          const cachedPageParams = cachedData?.pageParams ?? [];\n          const firstPageParam = cachedPageParams[0] ?? initialPageParam;\n          const totalPages = cachedPageParams.length;\n          result = await fetchPage(existingData, firstPageParam, maxPages);\n          if (forceQueryFn) {\n            result = {\n              data: result.data.pages[0]\n            };\n          }\n          for (let i = 1; i < totalPages; i++) {\n            const param = getNextPageParam(infiniteQueryOptions, result.data, arg.originalArgs);\n            result = await fetchPage(result.data, param, maxPages);\n          }\n        }\n        finalQueryReturnValue = result;\n      } else {\n        finalQueryReturnValue = await executeRequest(arg.originalArgs);\n      }\n      if (metaSchema && !shouldSkip(skipSchemaValidation, \"meta\") && finalQueryReturnValue.meta) {\n        finalQueryReturnValue.meta = await parseWithSchema(metaSchema, finalQueryReturnValue.meta, \"metaSchema\", finalQueryReturnValue.meta);\n      }\n      return fulfillWithValue(finalQueryReturnValue.data, addShouldAutoBatch({\n        fulfilledTimeStamp: Date.now(),\n        baseQueryMeta: finalQueryReturnValue.meta\n      }));\n    } catch (error) {\n      let caughtError = error;\n      if (caughtError instanceof HandledError) {\n        let transformErrorResponse = getTransformCallbackForEndpoint(endpointDefinition, \"transformErrorResponse\");\n        const {\n          rawErrorResponseSchema,\n          errorResponseSchema\n        } = endpointDefinition;\n        let {\n          value,\n          meta\n        } = caughtError;\n        try {\n          if (rawErrorResponseSchema && !shouldSkip(skipSchemaValidation, \"rawErrorResponse\")) {\n            value = await parseWithSchema(rawErrorResponseSchema, value, \"rawErrorResponseSchema\", meta);\n          }\n          if (metaSchema && !shouldSkip(skipSchemaValidation, \"meta\")) {\n            meta = await parseWithSchema(metaSchema, meta, \"metaSchema\", meta);\n          }\n          let transformedErrorResponse = await transformErrorResponse(value, meta, arg.originalArgs);\n          if (errorResponseSchema && !shouldSkip(skipSchemaValidation, \"errorResponse\")) {\n            transformedErrorResponse = await parseWithSchema(errorResponseSchema, transformedErrorResponse, \"errorResponseSchema\", meta);\n          }\n          return rejectWithValue(transformedErrorResponse, addShouldAutoBatch({\n            baseQueryMeta: meta\n          }));\n        } catch (e) {\n          caughtError = e;\n        }\n      }\n      try {\n        if (caughtError instanceof NamedSchemaError) {\n          const info = {\n            endpoint: arg.endpointName,\n            arg: arg.originalArgs,\n            type: arg.type,\n            queryCacheKey: arg.type === \"query\" ? arg.queryCacheKey : void 0\n          };\n          endpointDefinition.onSchemaFailure?.(caughtError, info);\n          onSchemaFailure?.(caughtError, info);\n          const {\n            catchSchemaFailure = globalCatchSchemaFailure\n          } = endpointDefinition;\n          if (catchSchemaFailure) {\n            return rejectWithValue(catchSchemaFailure(caughtError, info), addShouldAutoBatch({\n              baseQueryMeta: caughtError._bqMeta\n            }));\n          }\n        }\n      } catch (e) {\n        caughtError = e;\n      }\n      if (typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\") {\n        console.error(`An unhandled error occurred processing a request for the endpoint \"${arg.endpointName}\".\nIn the case of an unhandled error, no tags will be \"provided\" or \"invalidated\".`, caughtError);\n      } else {\n        console.error(caughtError);\n      }\n      throw caughtError;\n    }\n  };\n  function isForcedQuery(arg, state) {\n    const requestState = selectors.selectQueryEntry(state, arg.queryCacheKey);\n    const baseFetchOnMountOrArgChange = selectors.selectConfig(state).refetchOnMountOrArgChange;\n    const fulfilledVal = requestState?.fulfilledTimeStamp;\n    const refetchVal = arg.forceRefetch ?? (arg.subscribe && baseFetchOnMountOrArgChange);\n    if (refetchVal) {\n      return refetchVal === true || (Number(/* @__PURE__ */ new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;\n    }\n    return false;\n  }\n  const createQueryThunk = () => {\n    const generatedQueryThunk = createAsyncThunk(`${reducerPath}/executeQuery`, executeEndpoint, {\n      getPendingMeta({\n        arg\n      }) {\n        const endpointDefinition = endpointDefinitions[arg.endpointName];\n        return addShouldAutoBatch({\n          startedTimeStamp: Date.now(),\n          ...isInfiniteQueryDefinition(endpointDefinition) ? {\n            direction: arg.direction\n          } : {}\n        });\n      },\n      condition(queryThunkArg, {\n        getState\n      }) {\n        const state = getState();\n        const requestState = selectors.selectQueryEntry(state, queryThunkArg.queryCacheKey);\n        const fulfilledVal = requestState?.fulfilledTimeStamp;\n        const currentArg = queryThunkArg.originalArgs;\n        const previousArg = requestState?.originalArgs;\n        const endpointDefinition = endpointDefinitions[queryThunkArg.endpointName];\n        const direction = queryThunkArg.direction;\n        if (isUpsertQuery(queryThunkArg)) {\n          return true;\n        }\n        if (requestState?.status === \"pending\") {\n          return false;\n        }\n        if (isForcedQuery(queryThunkArg, state)) {\n          return true;\n        }\n        if (isQueryDefinition(endpointDefinition) && endpointDefinition?.forceRefetch?.({\n          currentArg,\n          previousArg,\n          endpointState: requestState,\n          state\n        })) {\n          return true;\n        }\n        if (fulfilledVal && !direction) {\n          return false;\n        }\n        return true;\n      },\n      dispatchConditionRejection: true\n    });\n    return generatedQueryThunk;\n  };\n  const queryThunk = createQueryThunk();\n  const infiniteQueryThunk = createQueryThunk();\n  const mutationThunk = createAsyncThunk(`${reducerPath}/executeMutation`, executeEndpoint, {\n    getPendingMeta() {\n      return addShouldAutoBatch({\n        startedTimeStamp: Date.now()\n      });\n    }\n  });\n  const hasTheForce = (options) => \"force\" in options;\n  const hasMaxAge = (options) => \"ifOlderThan\" in options;\n  const prefetch = (endpointName, arg, options = {}) => (dispatch, getState) => {\n    const force = hasTheForce(options) && options.force;\n    const maxAge = hasMaxAge(options) && options.ifOlderThan;\n    const queryAction = (force2 = true) => {\n      const options2 = {\n        forceRefetch: force2,\n        subscribe: false\n      };\n      return api.endpoints[endpointName].initiate(arg, options2);\n    };\n    const latestStateValue = api.endpoints[endpointName].select(arg)(getState());\n    if (force) {\n      dispatch(queryAction());\n    } else if (maxAge) {\n      const lastFulfilledTs = latestStateValue?.fulfilledTimeStamp;\n      if (!lastFulfilledTs) {\n        dispatch(queryAction());\n        return;\n      }\n      const shouldRetrigger = (Number(/* @__PURE__ */ new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;\n      if (shouldRetrigger) {\n        dispatch(queryAction());\n      }\n    } else {\n      dispatch(queryAction(false));\n    }\n  };\n  function matchesEndpoint(endpointName) {\n    return (action) => action?.meta?.arg?.endpointName === endpointName;\n  }\n  function buildMatchThunkActions(thunk, endpointName) {\n    return {\n      matchPending: isAllOf(isPending(thunk), matchesEndpoint(endpointName)),\n      matchFulfilled: isAllOf(isFulfilled(thunk), matchesEndpoint(endpointName)),\n      matchRejected: isAllOf(isRejected(thunk), matchesEndpoint(endpointName))\n    };\n  }\n  return {\n    queryThunk,\n    mutationThunk,\n    infiniteQueryThunk,\n    prefetch,\n    updateQueryData,\n    upsertQueryData,\n    patchQueryData,\n    buildMatchThunkActions\n  };\n}\nfunction getNextPageParam(options, {\n  pages,\n  pageParams\n}, queryArg) {\n  const lastIndex = pages.length - 1;\n  return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams, queryArg);\n}\nfunction getPreviousPageParam(options, {\n  pages,\n  pageParams\n}, queryArg) {\n  return options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams, queryArg);\n}\nfunction calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {\n  return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], isFulfilled(action) ? action.payload : void 0, isRejectedWithValue(action) ? action.payload : void 0, action.meta.arg.originalArgs, \"baseQueryMeta\" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);\n}\n\n// src/query/core/buildSlice.ts\nimport { isDraft } from \"immer\";\nimport { applyPatches, original } from \"immer\";\nfunction updateQuerySubstateIfExists(state, queryCacheKey, update) {\n  const substate = state[queryCacheKey];\n  if (substate) {\n    update(substate);\n  }\n}\nfunction getMutationCacheKey(id) {\n  return (\"arg\" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) ?? id.requestId;\n}\nfunction updateMutationSubstateIfExists(state, id, update) {\n  const substate = state[getMutationCacheKey(id)];\n  if (substate) {\n    update(substate);\n  }\n}\nvar initialState = {};\nfunction buildSlice({\n  reducerPath,\n  queryThunk,\n  mutationThunk,\n  serializeQueryArgs,\n  context: {\n    endpointDefinitions: definitions,\n    apiUid,\n    extractRehydrationInfo,\n    hasRehydrationInfo\n  },\n  assertTagType,\n  config\n}) {\n  const resetApiState = createAction(`${reducerPath}/resetApiState`);\n  function writePendingCacheEntry(draft, arg, upserting, meta) {\n    draft[arg.queryCacheKey] ??= {\n      status: \"uninitialized\" /* uninitialized */,\n      endpointName: arg.endpointName\n    };\n    updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {\n      substate.status = \"pending\" /* pending */;\n      substate.requestId = upserting && substate.requestId ? (\n        // for `upsertQuery` **updates**, keep the current `requestId`\n        substate.requestId\n      ) : (\n        // for normal queries or `upsertQuery` **inserts** always update the `requestId`\n        meta.requestId\n      );\n      if (arg.originalArgs !== void 0) {\n        substate.originalArgs = arg.originalArgs;\n      }\n      substate.startedTimeStamp = meta.startedTimeStamp;\n      const endpointDefinition = definitions[meta.arg.endpointName];\n      if (isInfiniteQueryDefinition(endpointDefinition) && \"direction\" in arg) {\n        ;\n        substate.direction = arg.direction;\n      }\n    });\n  }\n  function writeFulfilledCacheEntry(draft, meta, payload, upserting) {\n    updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, (substate) => {\n      if (substate.requestId !== meta.requestId && !upserting) return;\n      const {\n        merge\n      } = definitions[meta.arg.endpointName];\n      substate.status = \"fulfilled\" /* fulfilled */;\n      if (merge) {\n        if (substate.data !== void 0) {\n          const {\n            fulfilledTimeStamp,\n            arg,\n            baseQueryMeta,\n            requestId\n          } = meta;\n          let newData = createNextState(substate.data, (draftSubstateData) => {\n            return merge(draftSubstateData, payload, {\n              arg: arg.originalArgs,\n              baseQueryMeta,\n              fulfilledTimeStamp,\n              requestId\n            });\n          });\n          substate.data = newData;\n        } else {\n          substate.data = payload;\n        }\n      } else {\n        substate.data = definitions[meta.arg.endpointName].structuralSharing ?? true ? copyWithStructuralSharing(isDraft(substate.data) ? original(substate.data) : substate.data, payload) : payload;\n      }\n      delete substate.error;\n      substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n    });\n  }\n  const querySlice = createSlice({\n    name: `${reducerPath}/queries`,\n    initialState,\n    reducers: {\n      removeQueryResult: {\n        reducer(draft, {\n          payload: {\n            queryCacheKey\n          }\n        }) {\n          delete draft[queryCacheKey];\n        },\n        prepare: prepareAutoBatched()\n      },\n      cacheEntriesUpserted: {\n        reducer(draft, action) {\n          for (const entry of action.payload) {\n            const {\n              queryDescription: arg,\n              value\n            } = entry;\n            writePendingCacheEntry(draft, arg, true, {\n              arg,\n              requestId: action.meta.requestId,\n              startedTimeStamp: action.meta.timestamp\n            });\n            writeFulfilledCacheEntry(\n              draft,\n              {\n                arg,\n                requestId: action.meta.requestId,\n                fulfilledTimeStamp: action.meta.timestamp,\n                baseQueryMeta: {}\n              },\n              value,\n              // We know we're upserting here\n              true\n            );\n          }\n        },\n        prepare: (payload) => {\n          const queryDescriptions = payload.map((entry) => {\n            const {\n              endpointName,\n              arg,\n              value\n            } = entry;\n            const endpointDefinition = definitions[endpointName];\n            const queryDescription = {\n              type: \"query\",\n              endpointName,\n              originalArgs: entry.arg,\n              queryCacheKey: serializeQueryArgs({\n                queryArgs: arg,\n                endpointDefinition,\n                endpointName\n              })\n            };\n            return {\n              queryDescription,\n              value\n            };\n          });\n          const result = {\n            payload: queryDescriptions,\n            meta: {\n              [SHOULD_AUTOBATCH]: true,\n              requestId: nanoid(),\n              timestamp: Date.now()\n            }\n          };\n          return result;\n        }\n      },\n      queryResultPatched: {\n        reducer(draft, {\n          payload: {\n            queryCacheKey,\n            patches\n          }\n        }) {\n          updateQuerySubstateIfExists(draft, queryCacheKey, (substate) => {\n            substate.data = applyPatches(substate.data, patches.concat());\n          });\n        },\n        prepare: prepareAutoBatched()\n      }\n    },\n    extraReducers(builder) {\n      builder.addCase(queryThunk.pending, (draft, {\n        meta,\n        meta: {\n          arg\n        }\n      }) => {\n        const upserting = isUpsertQuery(arg);\n        writePendingCacheEntry(draft, arg, upserting, meta);\n      }).addCase(queryThunk.fulfilled, (draft, {\n        meta,\n        payload\n      }) => {\n        const upserting = isUpsertQuery(meta.arg);\n        writeFulfilledCacheEntry(draft, meta, payload, upserting);\n      }).addCase(queryThunk.rejected, (draft, {\n        meta: {\n          condition,\n          arg,\n          requestId\n        },\n        error,\n        payload\n      }) => {\n        updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {\n          if (condition) {\n          } else {\n            if (substate.requestId !== requestId) return;\n            substate.status = \"rejected\" /* rejected */;\n            substate.error = payload ?? error;\n          }\n        });\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\n        const {\n          queries\n        } = extractRehydrationInfo(action);\n        for (const [key, entry] of Object.entries(queries)) {\n          if (\n            // do not rehydrate entries that were currently in flight.\n            entry?.status === \"fulfilled\" /* fulfilled */ || entry?.status === \"rejected\" /* rejected */\n          ) {\n            draft[key] = entry;\n          }\n        }\n      });\n    }\n  });\n  const mutationSlice = createSlice({\n    name: `${reducerPath}/mutations`,\n    initialState,\n    reducers: {\n      removeMutationResult: {\n        reducer(draft, {\n          payload\n        }) {\n          const cacheKey = getMutationCacheKey(payload);\n          if (cacheKey in draft) {\n            delete draft[cacheKey];\n          }\n        },\n        prepare: prepareAutoBatched()\n      }\n    },\n    extraReducers(builder) {\n      builder.addCase(mutationThunk.pending, (draft, {\n        meta,\n        meta: {\n          requestId,\n          arg,\n          startedTimeStamp\n        }\n      }) => {\n        if (!arg.track) return;\n        draft[getMutationCacheKey(meta)] = {\n          requestId,\n          status: \"pending\" /* pending */,\n          endpointName: arg.endpointName,\n          startedTimeStamp\n        };\n      }).addCase(mutationThunk.fulfilled, (draft, {\n        payload,\n        meta\n      }) => {\n        if (!meta.arg.track) return;\n        updateMutationSubstateIfExists(draft, meta, (substate) => {\n          if (substate.requestId !== meta.requestId) return;\n          substate.status = \"fulfilled\" /* fulfilled */;\n          substate.data = payload;\n          substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n        });\n      }).addCase(mutationThunk.rejected, (draft, {\n        payload,\n        error,\n        meta\n      }) => {\n        if (!meta.arg.track) return;\n        updateMutationSubstateIfExists(draft, meta, (substate) => {\n          if (substate.requestId !== meta.requestId) return;\n          substate.status = \"rejected\" /* rejected */;\n          substate.error = payload ?? error;\n        });\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\n        const {\n          mutations\n        } = extractRehydrationInfo(action);\n        for (const [key, entry] of Object.entries(mutations)) {\n          if (\n            // do not rehydrate entries that were currently in flight.\n            (entry?.status === \"fulfilled\" /* fulfilled */ || entry?.status === \"rejected\" /* rejected */) && // only rehydrate endpoints that were persisted using a `fixedCacheKey`\n            key !== entry?.requestId\n          ) {\n            draft[key] = entry;\n          }\n        }\n      });\n    }\n  });\n  const initialInvalidationState = {\n    tags: {},\n    keys: {}\n  };\n  const invalidationSlice = createSlice({\n    name: `${reducerPath}/invalidation`,\n    initialState: initialInvalidationState,\n    reducers: {\n      updateProvidedBy: {\n        reducer(draft, action) {\n          for (const {\n            queryCacheKey,\n            providedTags\n          } of action.payload) {\n            removeCacheKeyFromTags(draft, queryCacheKey);\n            for (const {\n              type,\n              id\n            } of providedTags) {\n              const subscribedQueries = (draft.tags[type] ??= {})[id || \"__internal_without_id\"] ??= [];\n              const alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n              if (!alreadySubscribed) {\n                subscribedQueries.push(queryCacheKey);\n              }\n            }\n            draft.keys[queryCacheKey] = providedTags;\n          }\n        },\n        prepare: prepareAutoBatched()\n      }\n    },\n    extraReducers(builder) {\n      builder.addCase(querySlice.actions.removeQueryResult, (draft, {\n        payload: {\n          queryCacheKey\n        }\n      }) => {\n        removeCacheKeyFromTags(draft, queryCacheKey);\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\n        const {\n          provided\n        } = extractRehydrationInfo(action);\n        for (const [type, incomingTags] of Object.entries(provided.tags ?? {})) {\n          for (const [id, cacheKeys] of Object.entries(incomingTags)) {\n            const subscribedQueries = (draft.tags[type] ??= {})[id || \"__internal_without_id\"] ??= [];\n            for (const queryCacheKey of cacheKeys) {\n              const alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n              if (!alreadySubscribed) {\n                subscribedQueries.push(queryCacheKey);\n              }\n              draft.keys[queryCacheKey] = provided.keys[queryCacheKey];\n            }\n          }\n        }\n      }).addMatcher(isAnyOf(isFulfilled(queryThunk), isRejectedWithValue(queryThunk)), (draft, action) => {\n        writeProvidedTagsForQueries(draft, [action]);\n      }).addMatcher(querySlice.actions.cacheEntriesUpserted.match, (draft, action) => {\n        const mockActions = action.payload.map(({\n          queryDescription,\n          value\n        }) => {\n          return {\n            type: \"UNKNOWN\",\n            payload: value,\n            meta: {\n              requestStatus: \"fulfilled\",\n              requestId: \"UNKNOWN\",\n              arg: queryDescription\n            }\n          };\n        });\n        writeProvidedTagsForQueries(draft, mockActions);\n      });\n    }\n  });\n  function removeCacheKeyFromTags(draft, queryCacheKey) {\n    const existingTags = draft.keys[queryCacheKey] ?? [];\n    for (const tag of existingTags) {\n      const tagType = tag.type;\n      const tagId = tag.id ?? \"__internal_without_id\";\n      const tagSubscriptions = draft.tags[tagType]?.[tagId];\n      if (tagSubscriptions) {\n        draft.tags[tagType][tagId] = tagSubscriptions.filter((qc) => qc !== queryCacheKey);\n      }\n    }\n    delete draft.keys[queryCacheKey];\n  }\n  function writeProvidedTagsForQueries(draft, actions2) {\n    const providedByEntries = actions2.map((action) => {\n      const providedTags = calculateProvidedByThunk(action, \"providesTags\", definitions, assertTagType);\n      const {\n        queryCacheKey\n      } = action.meta.arg;\n      return {\n        queryCacheKey,\n        providedTags\n      };\n    });\n    invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy(providedByEntries));\n  }\n  const subscriptionSlice = createSlice({\n    name: `${reducerPath}/subscriptions`,\n    initialState,\n    reducers: {\n      updateSubscriptionOptions(d, a) {\n      },\n      unsubscribeQueryResult(d, a) {\n      },\n      internal_getRTKQSubscriptions() {\n      }\n    }\n  });\n  const internalSubscriptionsSlice = createSlice({\n    name: `${reducerPath}/internalSubscriptions`,\n    initialState,\n    reducers: {\n      subscriptionsUpdated: {\n        reducer(state, action) {\n          return applyPatches(state, action.payload);\n        },\n        prepare: prepareAutoBatched()\n      }\n    }\n  });\n  const configSlice = createSlice({\n    name: `${reducerPath}/config`,\n    initialState: {\n      online: isOnline(),\n      focused: isDocumentVisible(),\n      middlewareRegistered: false,\n      ...config\n    },\n    reducers: {\n      middlewareRegistered(state, {\n        payload\n      }) {\n        state.middlewareRegistered = state.middlewareRegistered === \"conflict\" || apiUid !== payload ? \"conflict\" : true;\n      }\n    },\n    extraReducers: (builder) => {\n      builder.addCase(onOnline, (state) => {\n        state.online = true;\n      }).addCase(onOffline, (state) => {\n        state.online = false;\n      }).addCase(onFocus, (state) => {\n        state.focused = true;\n      }).addCase(onFocusLost, (state) => {\n        state.focused = false;\n      }).addMatcher(hasRehydrationInfo, (draft) => ({\n        ...draft\n      }));\n    }\n  });\n  const combinedReducer = combineReducers({\n    queries: querySlice.reducer,\n    mutations: mutationSlice.reducer,\n    provided: invalidationSlice.reducer,\n    subscriptions: internalSubscriptionsSlice.reducer,\n    config: configSlice.reducer\n  });\n  const reducer = (state, action) => combinedReducer(resetApiState.match(action) ? void 0 : state, action);\n  const actions = {\n    ...configSlice.actions,\n    ...querySlice.actions,\n    ...subscriptionSlice.actions,\n    ...internalSubscriptionsSlice.actions,\n    ...mutationSlice.actions,\n    ...invalidationSlice.actions,\n    resetApiState\n  };\n  return {\n    reducer,\n    actions\n  };\n}\n\n// src/query/core/buildSelectors.ts\nvar skipToken = /* @__PURE__ */ Symbol.for(\"RTKQ/skipToken\");\nvar initialSubState = {\n  status: \"uninitialized\" /* uninitialized */\n};\nvar defaultQuerySubState = /* @__PURE__ */ createNextState(initialSubState, () => {\n});\nvar defaultMutationSubState = /* @__PURE__ */ createNextState(initialSubState, () => {\n});\nfunction buildSelectors({\n  serializeQueryArgs,\n  reducerPath,\n  createSelector: createSelector2\n}) {\n  const selectSkippedQuery = (state) => defaultQuerySubState;\n  const selectSkippedMutation = (state) => defaultMutationSubState;\n  return {\n    buildQuerySelector,\n    buildInfiniteQuerySelector,\n    buildMutationSelector,\n    selectInvalidatedBy,\n    selectCachedArgsForQuery,\n    selectApiState,\n    selectQueries,\n    selectMutations,\n    selectQueryEntry,\n    selectConfig\n  };\n  function withRequestFlags(substate) {\n    return {\n      ...substate,\n      ...getRequestStatusFlags(substate.status)\n    };\n  }\n  function selectApiState(rootState) {\n    const state = rootState[reducerPath];\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!state) {\n        if (selectApiState.triggered) return state;\n        selectApiState.triggered = true;\n        console.error(`Error: No data found at \\`state.${reducerPath}\\`. Did you forget to add the reducer to the store?`);\n      }\n    }\n    return state;\n  }\n  function selectQueries(rootState) {\n    return selectApiState(rootState)?.queries;\n  }\n  function selectQueryEntry(rootState, cacheKey) {\n    return selectQueries(rootState)?.[cacheKey];\n  }\n  function selectMutations(rootState) {\n    return selectApiState(rootState)?.mutations;\n  }\n  function selectConfig(rootState) {\n    return selectApiState(rootState)?.config;\n  }\n  function buildAnyQuerySelector(endpointName, endpointDefinition, combiner) {\n    return (queryArgs) => {\n      if (queryArgs === skipToken) {\n        return createSelector2(selectSkippedQuery, combiner);\n      }\n      const serializedArgs = serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      });\n      const selectQuerySubstate = (state) => selectQueryEntry(state, serializedArgs) ?? defaultQuerySubState;\n      return createSelector2(selectQuerySubstate, combiner);\n    };\n  }\n  function buildQuerySelector(endpointName, endpointDefinition) {\n    return buildAnyQuerySelector(endpointName, endpointDefinition, withRequestFlags);\n  }\n  function buildInfiniteQuerySelector(endpointName, endpointDefinition) {\n    const {\n      infiniteQueryOptions\n    } = endpointDefinition;\n    function withInfiniteQueryResultFlags(substate) {\n      const stateWithRequestFlags = {\n        ...substate,\n        ...getRequestStatusFlags(substate.status)\n      };\n      const {\n        isLoading,\n        isError,\n        direction\n      } = stateWithRequestFlags;\n      const isForward = direction === \"forward\";\n      const isBackward = direction === \"backward\";\n      return {\n        ...stateWithRequestFlags,\n        hasNextPage: getHasNextPage(infiniteQueryOptions, stateWithRequestFlags.data, stateWithRequestFlags.originalArgs),\n        hasPreviousPage: getHasPreviousPage(infiniteQueryOptions, stateWithRequestFlags.data, stateWithRequestFlags.originalArgs),\n        isFetchingNextPage: isLoading && isForward,\n        isFetchingPreviousPage: isLoading && isBackward,\n        isFetchNextPageError: isError && isForward,\n        isFetchPreviousPageError: isError && isBackward\n      };\n    }\n    return buildAnyQuerySelector(endpointName, endpointDefinition, withInfiniteQueryResultFlags);\n  }\n  function buildMutationSelector() {\n    return (id) => {\n      let mutationId;\n      if (typeof id === \"object\") {\n        mutationId = getMutationCacheKey(id) ?? skipToken;\n      } else {\n        mutationId = id;\n      }\n      const selectMutationSubstate = (state) => selectApiState(state)?.mutations?.[mutationId] ?? defaultMutationSubState;\n      const finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;\n      return createSelector2(finalSelectMutationSubstate, withRequestFlags);\n    };\n  }\n  function selectInvalidatedBy(state, tags) {\n    const apiState = state[reducerPath];\n    const toInvalidate = /* @__PURE__ */ new Set();\n    for (const tag of tags.filter(isNotNullish).map(expandTagDescription)) {\n      const provided = apiState.provided.tags[tag.type];\n      if (!provided) {\n        continue;\n      }\n      let invalidateSubscriptions = (tag.id !== void 0 ? (\n        // id given: invalidate all queries that provide this type & id\n        provided[tag.id]\n      ) : (\n        // no id: invalidate all queries that provide this type\n        flatten(Object.values(provided))\n      )) ?? [];\n      for (const invalidate of invalidateSubscriptions) {\n        toInvalidate.add(invalidate);\n      }\n    }\n    return flatten(Array.from(toInvalidate.values()).map((queryCacheKey) => {\n      const querySubState = apiState.queries[queryCacheKey];\n      return querySubState ? [{\n        queryCacheKey,\n        endpointName: querySubState.endpointName,\n        originalArgs: querySubState.originalArgs\n      }] : [];\n    }));\n  }\n  function selectCachedArgsForQuery(state, queryName) {\n    return Object.values(selectQueries(state)).filter((entry) => entry?.endpointName === queryName && entry.status !== \"uninitialized\" /* uninitialized */).map((entry) => entry.originalArgs);\n  }\n  function getHasNextPage(options, data, queryArg) {\n    if (!data) return false;\n    return getNextPageParam(options, data, queryArg) != null;\n  }\n  function getHasPreviousPage(options, data, queryArg) {\n    if (!data || !options.getPreviousPageParam) return false;\n    return getPreviousPageParam(options, data, queryArg) != null;\n  }\n}\n\n// src/query/createApi.ts\nimport { formatProdErrorMessage as _formatProdErrorMessage2, formatProdErrorMessage as _formatProdErrorMessage22, formatProdErrorMessage as _formatProdErrorMessage3 } from \"@reduxjs/toolkit\";\n\n// src/query/defaultSerializeQueryArgs.ts\nvar cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;\nvar defaultSerializeQueryArgs = ({\n  endpointName,\n  queryArgs\n}) => {\n  let serialized = \"\";\n  const cached = cache?.get(queryArgs);\n  if (typeof cached === \"string\") {\n    serialized = cached;\n  } else {\n    const stringified = JSON.stringify(queryArgs, (key, value) => {\n      value = typeof value === \"bigint\" ? {\n        $bigint: value.toString()\n      } : value;\n      value = isPlainObject(value) ? Object.keys(value).sort().reduce((acc, key2) => {\n        acc[key2] = value[key2];\n        return acc;\n      }, {}) : value;\n      return value;\n    });\n    if (isPlainObject(queryArgs)) {\n      cache?.set(queryArgs, stringified);\n    }\n    serialized = stringified;\n  }\n  return `${endpointName}(${serialized})`;\n};\n\n// src/query/createApi.ts\nimport { weakMapMemoize } from \"reselect\";\nfunction buildCreateApi(...modules) {\n  return function baseCreateApi(options) {\n    const extractRehydrationInfo = weakMapMemoize((action) => options.extractRehydrationInfo?.(action, {\n      reducerPath: options.reducerPath ?? \"api\"\n    }));\n    const optionsWithDefaults = {\n      reducerPath: \"api\",\n      keepUnusedDataFor: 60,\n      refetchOnMountOrArgChange: false,\n      refetchOnFocus: false,\n      refetchOnReconnect: false,\n      invalidationBehavior: \"delayed\",\n      ...options,\n      extractRehydrationInfo,\n      serializeQueryArgs(queryArgsApi) {\n        let finalSerializeQueryArgs = defaultSerializeQueryArgs;\n        if (\"serializeQueryArgs\" in queryArgsApi.endpointDefinition) {\n          const endpointSQA = queryArgsApi.endpointDefinition.serializeQueryArgs;\n          finalSerializeQueryArgs = (queryArgsApi2) => {\n            const initialResult = endpointSQA(queryArgsApi2);\n            if (typeof initialResult === \"string\") {\n              return initialResult;\n            } else {\n              return defaultSerializeQueryArgs({\n                ...queryArgsApi2,\n                queryArgs: initialResult\n              });\n            }\n          };\n        } else if (options.serializeQueryArgs) {\n          finalSerializeQueryArgs = options.serializeQueryArgs;\n        }\n        return finalSerializeQueryArgs(queryArgsApi);\n      },\n      tagTypes: [...options.tagTypes || []]\n    };\n    const context = {\n      endpointDefinitions: {},\n      batch(fn) {\n        fn();\n      },\n      apiUid: nanoid(),\n      extractRehydrationInfo,\n      hasRehydrationInfo: weakMapMemoize((action) => extractRehydrationInfo(action) != null)\n    };\n    const api = {\n      injectEndpoints,\n      enhanceEndpoints({\n        addTagTypes,\n        endpoints\n      }) {\n        if (addTagTypes) {\n          for (const eT of addTagTypes) {\n            if (!optionsWithDefaults.tagTypes.includes(eT)) {\n              ;\n              optionsWithDefaults.tagTypes.push(eT);\n            }\n          }\n        }\n        if (endpoints) {\n          for (const [endpointName, partialDefinition] of Object.entries(endpoints)) {\n            if (typeof partialDefinition === \"function\") {\n              partialDefinition(context.endpointDefinitions[endpointName]);\n            } else {\n              Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);\n            }\n          }\n        }\n        return api;\n      }\n    };\n    const initializedModules = modules.map((m) => m.init(api, optionsWithDefaults, context));\n    function injectEndpoints(inject) {\n      const evaluatedEndpoints = inject.endpoints({\n        query: (x) => ({\n          ...x,\n          type: \"query\" /* query */\n        }),\n        mutation: (x) => ({\n          ...x,\n          type: \"mutation\" /* mutation */\n        }),\n        infiniteQuery: (x) => ({\n          ...x,\n          type: \"infinitequery\" /* infinitequery */\n        })\n      });\n      for (const [endpointName, definition] of Object.entries(evaluatedEndpoints)) {\n        if (inject.overrideExisting !== true && endpointName in context.endpointDefinitions) {\n          if (inject.overrideExisting === \"throw\") {\n            throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage2(39) : `called \\`injectEndpoints\\` to override already-existing endpointName ${endpointName} without specifying \\`overrideExisting: true\\``);\n          } else if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n            console.error(`called \\`injectEndpoints\\` to override already-existing endpointName ${endpointName} without specifying \\`overrideExisting: true\\``);\n          }\n          continue;\n        }\n        if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n          if (isInfiniteQueryDefinition(definition)) {\n            const {\n              infiniteQueryOptions\n            } = definition;\n            const {\n              maxPages,\n              getPreviousPageParam: getPreviousPageParam2\n            } = infiniteQueryOptions;\n            if (typeof maxPages === \"number\") {\n              if (maxPages < 1) {\n                throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage22(40) : `maxPages for endpoint '${endpointName}' must be a number greater than 0`);\n              }\n              if (typeof getPreviousPageParam2 !== \"function\") {\n                throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage3(41) : `getPreviousPageParam for endpoint '${endpointName}' must be a function if maxPages is used`);\n              }\n            }\n          }\n        }\n        context.endpointDefinitions[endpointName] = definition;\n        for (const m of initializedModules) {\n          m.injectEndpoint(endpointName, definition);\n        }\n      }\n      return api;\n    }\n    return api.injectEndpoints({\n      endpoints: options.endpoints\n    });\n  };\n}\n\n// src/query/fakeBaseQuery.ts\nimport { formatProdErrorMessage as _formatProdErrorMessage4 } from \"@reduxjs/toolkit\";\nvar _NEVER = /* @__PURE__ */ Symbol();\nfunction fakeBaseQuery() {\n  return function() {\n    throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage4(33) : \"When using `fakeBaseQuery`, all queries & mutations must use the `queryFn` definition syntax.\");\n  };\n}\n\n// src/query/core/module.ts\nimport { enablePatches } from \"immer\";\n\n// src/query/tsHelpers.ts\nfunction assertCast(v) {\n}\nfunction safeAssign(target, ...args) {\n  return Object.assign(target, ...args);\n}\n\n// src/query/core/buildMiddleware/batchActions.ts\nimport { produceWithPatches as produceWithPatches2 } from \"immer\";\nvar buildBatchedActionsHandler = ({\n  api,\n  queryThunk,\n  internalState,\n  mwApi\n}) => {\n  const subscriptionsPrefix = `${api.reducerPath}/subscriptions`;\n  let previousSubscriptions = null;\n  let updateSyncTimer = null;\n  const {\n    updateSubscriptionOptions,\n    unsubscribeQueryResult\n  } = api.internalActions;\n  const actuallyMutateSubscriptions = (currentSubscriptions, action) => {\n    if (updateSubscriptionOptions.match(action)) {\n      const {\n        queryCacheKey,\n        requestId,\n        options\n      } = action.payload;\n      const sub = currentSubscriptions.get(queryCacheKey);\n      if (sub?.has(requestId)) {\n        sub.set(requestId, options);\n      }\n      return true;\n    }\n    if (unsubscribeQueryResult.match(action)) {\n      const {\n        queryCacheKey,\n        requestId\n      } = action.payload;\n      const sub = currentSubscriptions.get(queryCacheKey);\n      if (sub) {\n        sub.delete(requestId);\n      }\n      return true;\n    }\n    if (api.internalActions.removeQueryResult.match(action)) {\n      currentSubscriptions.delete(action.payload.queryCacheKey);\n      return true;\n    }\n    if (queryThunk.pending.match(action)) {\n      const {\n        meta: {\n          arg,\n          requestId\n        }\n      } = action;\n      const substate = getOrInsertComputed(currentSubscriptions, arg.queryCacheKey, createNewMap);\n      if (arg.subscribe) {\n        substate.set(requestId, arg.subscriptionOptions ?? substate.get(requestId) ?? {});\n      }\n      return true;\n    }\n    let mutated = false;\n    if (queryThunk.rejected.match(action)) {\n      const {\n        meta: {\n          condition,\n          arg,\n          requestId\n        }\n      } = action;\n      if (condition && arg.subscribe) {\n        const substate = getOrInsertComputed(currentSubscriptions, arg.queryCacheKey, createNewMap);\n        substate.set(requestId, arg.subscriptionOptions ?? substate.get(requestId) ?? {});\n        mutated = true;\n      }\n    }\n    return mutated;\n  };\n  const getSubscriptions = () => internalState.currentSubscriptions;\n  const getSubscriptionCount = (queryCacheKey) => {\n    const subscriptions = getSubscriptions();\n    const subscriptionsForQueryArg = subscriptions.get(queryCacheKey);\n    return subscriptionsForQueryArg?.size ?? 0;\n  };\n  const isRequestSubscribed = (queryCacheKey, requestId) => {\n    const subscriptions = getSubscriptions();\n    return !!subscriptions?.get(queryCacheKey)?.get(requestId);\n  };\n  const subscriptionSelectors = {\n    getSubscriptions,\n    getSubscriptionCount,\n    isRequestSubscribed\n  };\n  function serializeSubscriptions(currentSubscriptions) {\n    return JSON.parse(JSON.stringify(Object.fromEntries([...currentSubscriptions].map(([k, v]) => [k, Object.fromEntries(v)]))));\n  }\n  return (action, mwApi2) => {\n    if (!previousSubscriptions) {\n      previousSubscriptions = serializeSubscriptions(internalState.currentSubscriptions);\n    }\n    if (api.util.resetApiState.match(action)) {\n      previousSubscriptions = {};\n      internalState.currentSubscriptions.clear();\n      updateSyncTimer = null;\n      return [true, false];\n    }\n    if (api.internalActions.internal_getRTKQSubscriptions.match(action)) {\n      return [false, subscriptionSelectors];\n    }\n    const didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);\n    let actionShouldContinue = true;\n    if (process.env.NODE_ENV === \"test\" && typeof action.type === \"string\" && action.type === `${api.reducerPath}/getPolling`) {\n      return [false, internalState.currentPolls];\n    }\n    if (didMutate) {\n      if (!updateSyncTimer) {\n        updateSyncTimer = setTimeout(() => {\n          const newSubscriptions = serializeSubscriptions(internalState.currentSubscriptions);\n          const [, patches] = produceWithPatches2(previousSubscriptions, () => newSubscriptions);\n          mwApi2.next(api.internalActions.subscriptionsUpdated(patches));\n          previousSubscriptions = newSubscriptions;\n          updateSyncTimer = null;\n        }, 500);\n      }\n      const isSubscriptionSliceAction = typeof action.type == \"string\" && !!action.type.startsWith(subscriptionsPrefix);\n      const isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;\n      actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;\n    }\n    return [actionShouldContinue, false];\n  };\n};\n\n// src/query/core/buildMiddleware/cacheCollection.ts\nvar THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;\nvar buildCacheCollectionHandler = ({\n  reducerPath,\n  api,\n  queryThunk,\n  context,\n  internalState,\n  selectors: {\n    selectQueryEntry,\n    selectConfig\n  },\n  getRunningQueryThunk,\n  mwApi\n}) => {\n  const {\n    removeQueryResult,\n    unsubscribeQueryResult,\n    cacheEntriesUpserted\n  } = api.internalActions;\n  const canTriggerUnsubscribe = isAnyOf(unsubscribeQueryResult.match, queryThunk.fulfilled, queryThunk.rejected, cacheEntriesUpserted.match);\n  function anySubscriptionsRemainingForKey(queryCacheKey) {\n    const subscriptions = internalState.currentSubscriptions.get(queryCacheKey);\n    if (!subscriptions) {\n      return false;\n    }\n    const hasSubscriptions = subscriptions.size > 0;\n    return hasSubscriptions;\n  }\n  const currentRemovalTimeouts = {};\n  function abortAllPromises(promiseMap) {\n    for (const promise of promiseMap.values()) {\n      promise?.abort?.();\n    }\n  }\n  const handler = (action, mwApi2) => {\n    const state = mwApi2.getState();\n    const config = selectConfig(state);\n    if (canTriggerUnsubscribe(action)) {\n      let queryCacheKeys;\n      if (cacheEntriesUpserted.match(action)) {\n        queryCacheKeys = action.payload.map((entry) => entry.queryDescription.queryCacheKey);\n      } else {\n        const {\n          queryCacheKey\n        } = unsubscribeQueryResult.match(action) ? action.payload : action.meta.arg;\n        queryCacheKeys = [queryCacheKey];\n      }\n      handleUnsubscribeMany(queryCacheKeys, mwApi2, config);\n    }\n    if (api.util.resetApiState.match(action)) {\n      for (const [key, timeout] of Object.entries(currentRemovalTimeouts)) {\n        if (timeout) clearTimeout(timeout);\n        delete currentRemovalTimeouts[key];\n      }\n      abortAllPromises(internalState.runningQueries);\n      abortAllPromises(internalState.runningMutations);\n    }\n    if (context.hasRehydrationInfo(action)) {\n      const {\n        queries\n      } = context.extractRehydrationInfo(action);\n      handleUnsubscribeMany(Object.keys(queries), mwApi2, config);\n    }\n  };\n  function handleUnsubscribeMany(cacheKeys, api2, config) {\n    const state = api2.getState();\n    for (const queryCacheKey of cacheKeys) {\n      const entry = selectQueryEntry(state, queryCacheKey);\n      if (entry?.endpointName) {\n        handleUnsubscribe(queryCacheKey, entry.endpointName, api2, config);\n      }\n    }\n  }\n  function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {\n    const endpointDefinition = context.endpointDefinitions[endpointName];\n    const keepUnusedDataFor = endpointDefinition?.keepUnusedDataFor ?? config.keepUnusedDataFor;\n    if (keepUnusedDataFor === Infinity) {\n      return;\n    }\n    const finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));\n    if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n      const currentTimeout = currentRemovalTimeouts[queryCacheKey];\n      if (currentTimeout) {\n        clearTimeout(currentTimeout);\n      }\n      currentRemovalTimeouts[queryCacheKey] = setTimeout(() => {\n        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n          const entry = selectQueryEntry(api2.getState(), queryCacheKey);\n          if (entry?.endpointName) {\n            const runningQuery = api2.dispatch(getRunningQueryThunk(entry.endpointName, entry.originalArgs));\n            runningQuery?.abort();\n          }\n          api2.dispatch(removeQueryResult({\n            queryCacheKey\n          }));\n        }\n        delete currentRemovalTimeouts[queryCacheKey];\n      }, finalKeepUnusedDataFor * 1e3);\n    }\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/cacheLifecycle.ts\nvar neverResolvedError = new Error(\"Promise never resolved before cacheEntryRemoved.\");\nvar buildCacheLifecycleHandler = ({\n  api,\n  reducerPath,\n  context,\n  queryThunk,\n  mutationThunk,\n  internalState,\n  selectors: {\n    selectQueryEntry,\n    selectApiState\n  }\n}) => {\n  const isQueryThunk = isAsyncThunkAction(queryThunk);\n  const isMutationThunk = isAsyncThunkAction(mutationThunk);\n  const isFulfilledThunk = isFulfilled(queryThunk, mutationThunk);\n  const lifecycleMap = {};\n  function resolveLifecycleEntry(cacheKey, data, meta) {\n    const lifecycle = lifecycleMap[cacheKey];\n    if (lifecycle?.valueResolved) {\n      lifecycle.valueResolved({\n        data,\n        meta\n      });\n      delete lifecycle.valueResolved;\n    }\n  }\n  function removeLifecycleEntry(cacheKey) {\n    const lifecycle = lifecycleMap[cacheKey];\n    if (lifecycle) {\n      delete lifecycleMap[cacheKey];\n      lifecycle.cacheEntryRemoved();\n    }\n  }\n  const handler = (action, mwApi, stateBefore) => {\n    const cacheKey = getCacheKey(action);\n    function checkForNewCacheKey(endpointName, cacheKey2, requestId, originalArgs) {\n      const oldEntry = selectQueryEntry(stateBefore, cacheKey2);\n      const newEntry = selectQueryEntry(mwApi.getState(), cacheKey2);\n      if (!oldEntry && newEntry) {\n        handleNewKey(endpointName, originalArgs, cacheKey2, mwApi, requestId);\n      }\n    }\n    if (queryThunk.pending.match(action)) {\n      checkForNewCacheKey(action.meta.arg.endpointName, cacheKey, action.meta.requestId, action.meta.arg.originalArgs);\n    } else if (api.internalActions.cacheEntriesUpserted.match(action)) {\n      for (const {\n        queryDescription,\n        value\n      } of action.payload) {\n        const {\n          endpointName,\n          originalArgs,\n          queryCacheKey\n        } = queryDescription;\n        checkForNewCacheKey(endpointName, queryCacheKey, action.meta.requestId, originalArgs);\n        resolveLifecycleEntry(queryCacheKey, value, {});\n      }\n    } else if (mutationThunk.pending.match(action)) {\n      const state = mwApi.getState()[reducerPath].mutations[cacheKey];\n      if (state) {\n        handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);\n      }\n    } else if (isFulfilledThunk(action)) {\n      resolveLifecycleEntry(cacheKey, action.payload, action.meta.baseQueryMeta);\n    } else if (api.internalActions.removeQueryResult.match(action) || api.internalActions.removeMutationResult.match(action)) {\n      removeLifecycleEntry(cacheKey);\n    } else if (api.util.resetApiState.match(action)) {\n      for (const cacheKey2 of Object.keys(lifecycleMap)) {\n        removeLifecycleEntry(cacheKey2);\n      }\n    }\n  };\n  function getCacheKey(action) {\n    if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;\n    if (isMutationThunk(action)) {\n      return action.meta.arg.fixedCacheKey ?? action.meta.requestId;\n    }\n    if (api.internalActions.removeQueryResult.match(action)) return action.payload.queryCacheKey;\n    if (api.internalActions.removeMutationResult.match(action)) return getMutationCacheKey(action.payload);\n    return \"\";\n  }\n  function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {\n    const endpointDefinition = context.endpointDefinitions[endpointName];\n    const onCacheEntryAdded = endpointDefinition?.onCacheEntryAdded;\n    if (!onCacheEntryAdded) return;\n    const lifecycle = {};\n    const cacheEntryRemoved = new Promise((resolve) => {\n      lifecycle.cacheEntryRemoved = resolve;\n    });\n    const cacheDataLoaded = Promise.race([new Promise((resolve) => {\n      lifecycle.valueResolved = resolve;\n    }), cacheEntryRemoved.then(() => {\n      throw neverResolvedError;\n    })]);\n    cacheDataLoaded.catch(() => {\n    });\n    lifecycleMap[queryCacheKey] = lifecycle;\n    const selector = api.endpoints[endpointName].select(isAnyQueryDefinition(endpointDefinition) ? originalArgs : queryCacheKey);\n    const extra = mwApi.dispatch((_, __, extra2) => extra2);\n    const lifecycleApi = {\n      ...mwApi,\n      getCacheEntry: () => selector(mwApi.getState()),\n      requestId,\n      extra,\n      updateCachedData: isAnyQueryDefinition(endpointDefinition) ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,\n      cacheDataLoaded,\n      cacheEntryRemoved\n    };\n    const runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);\n    Promise.resolve(runningHandler).catch((e) => {\n      if (e === neverResolvedError) return;\n      throw e;\n    });\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/devMiddleware.ts\nvar buildDevCheckHandler = ({\n  api,\n  context: {\n    apiUid\n  },\n  reducerPath\n}) => {\n  return (action, mwApi) => {\n    if (api.util.resetApiState.match(action)) {\n      mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n    }\n    if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n      if (api.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && mwApi.getState()[reducerPath]?.config?.middlewareRegistered === \"conflict\") {\n        console.warn(`There is a mismatch between slice and middleware for the reducerPath \"${reducerPath}\".\nYou can only have one api per reducer path, this will lead to crashes in various situations!${reducerPath === \"api\" ? `\nIf you have multiple apis, you *have* to specify the reducerPath option when using createApi!` : \"\"}`);\n      }\n    }\n  };\n};\n\n// src/query/core/buildMiddleware/invalidationByTags.ts\nvar buildInvalidationByTagsHandler = ({\n  reducerPath,\n  context,\n  context: {\n    endpointDefinitions\n  },\n  mutationThunk,\n  queryThunk,\n  api,\n  assertTagType,\n  refetchQuery,\n  internalState\n}) => {\n  const {\n    removeQueryResult\n  } = api.internalActions;\n  const isThunkActionWithTags = isAnyOf(isFulfilled(mutationThunk), isRejectedWithValue(mutationThunk));\n  const isQueryEnd = isAnyOf(isFulfilled(mutationThunk, queryThunk), isRejected(mutationThunk, queryThunk));\n  let pendingTagInvalidations = [];\n  const handler = (action, mwApi) => {\n    if (isThunkActionWithTags(action)) {\n      invalidateTags(calculateProvidedByThunk(action, \"invalidatesTags\", endpointDefinitions, assertTagType), mwApi);\n    } else if (isQueryEnd(action)) {\n      invalidateTags([], mwApi);\n    } else if (api.util.invalidateTags.match(action)) {\n      invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);\n    }\n  };\n  function hasPendingRequests(state) {\n    const {\n      queries,\n      mutations\n    } = state;\n    for (const cacheRecord of [queries, mutations]) {\n      for (const key in cacheRecord) {\n        if (cacheRecord[key]?.status === \"pending\" /* pending */) return true;\n      }\n    }\n    return false;\n  }\n  function invalidateTags(newTags, mwApi) {\n    const rootState = mwApi.getState();\n    const state = rootState[reducerPath];\n    pendingTagInvalidations.push(...newTags);\n    if (state.config.invalidationBehavior === \"delayed\" && hasPendingRequests(state)) {\n      return;\n    }\n    const tags = pendingTagInvalidations;\n    pendingTagInvalidations = [];\n    if (tags.length === 0) return;\n    const toInvalidate = api.util.selectInvalidatedBy(rootState, tags);\n    context.batch(() => {\n      const valuesArray = Array.from(toInvalidate.values());\n      for (const {\n        queryCacheKey\n      } of valuesArray) {\n        const querySubState = state.queries[queryCacheKey];\n        const subscriptionSubState = getOrInsertComputed(internalState.currentSubscriptions, queryCacheKey, createNewMap);\n        if (querySubState) {\n          if (subscriptionSubState.size === 0) {\n            mwApi.dispatch(removeQueryResult({\n              queryCacheKey\n            }));\n          } else if (querySubState.status !== \"uninitialized\" /* uninitialized */) {\n            mwApi.dispatch(refetchQuery(querySubState));\n          }\n        }\n      }\n    });\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/polling.ts\nvar buildPollingHandler = ({\n  reducerPath,\n  queryThunk,\n  api,\n  refetchQuery,\n  internalState\n}) => {\n  const {\n    currentPolls,\n    currentSubscriptions\n  } = internalState;\n  const pendingPollingUpdates = /* @__PURE__ */ new Set();\n  let pollingUpdateTimer = null;\n  const handler = (action, mwApi) => {\n    if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {\n      schedulePollingUpdate(action.payload.queryCacheKey, mwApi);\n    }\n    if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {\n      schedulePollingUpdate(action.meta.arg.queryCacheKey, mwApi);\n    }\n    if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {\n      startNextPoll(action.meta.arg, mwApi);\n    }\n    if (api.util.resetApiState.match(action)) {\n      clearPolls();\n      if (pollingUpdateTimer) {\n        clearTimeout(pollingUpdateTimer);\n        pollingUpdateTimer = null;\n      }\n      pendingPollingUpdates.clear();\n    }\n  };\n  function schedulePollingUpdate(queryCacheKey, api2) {\n    pendingPollingUpdates.add(queryCacheKey);\n    if (!pollingUpdateTimer) {\n      pollingUpdateTimer = setTimeout(() => {\n        for (const key of pendingPollingUpdates) {\n          updatePollingInterval({\n            queryCacheKey: key\n          }, api2);\n        }\n        pendingPollingUpdates.clear();\n        pollingUpdateTimer = null;\n      }, 0);\n    }\n  }\n  function getCacheEntrySubscriptions(queryCacheKey, api2) {\n    const state = api2.getState()[reducerPath];\n    const querySubState = state.queries[queryCacheKey];\n    const subscriptions = currentSubscriptions.get(queryCacheKey);\n    if (!querySubState || querySubState.status === \"uninitialized\" /* uninitialized */) return;\n    return subscriptions;\n  }\n  function startNextPoll({\n    queryCacheKey\n  }, api2) {\n    const state = api2.getState()[reducerPath];\n    const querySubState = state.queries[queryCacheKey];\n    const subscriptions = currentSubscriptions.get(queryCacheKey);\n    if (!querySubState || querySubState.status === \"uninitialized\" /* uninitialized */) return;\n    const {\n      lowestPollingInterval,\n      skipPollingIfUnfocused\n    } = findLowestPollingInterval(subscriptions);\n    if (!Number.isFinite(lowestPollingInterval)) return;\n    const currentPoll = currentPolls.get(queryCacheKey);\n    if (currentPoll?.timeout) {\n      clearTimeout(currentPoll.timeout);\n      currentPoll.timeout = void 0;\n    }\n    const nextPollTimestamp = Date.now() + lowestPollingInterval;\n    currentPolls.set(queryCacheKey, {\n      nextPollTimestamp,\n      pollingInterval: lowestPollingInterval,\n      timeout: setTimeout(() => {\n        if (state.config.focused || !skipPollingIfUnfocused) {\n          api2.dispatch(refetchQuery(querySubState));\n        }\n        startNextPoll({\n          queryCacheKey\n        }, api2);\n      }, lowestPollingInterval)\n    });\n  }\n  function updatePollingInterval({\n    queryCacheKey\n  }, api2) {\n    const state = api2.getState()[reducerPath];\n    const querySubState = state.queries[queryCacheKey];\n    const subscriptions = currentSubscriptions.get(queryCacheKey);\n    if (!querySubState || querySubState.status === \"uninitialized\" /* uninitialized */) {\n      return;\n    }\n    const {\n      lowestPollingInterval\n    } = findLowestPollingInterval(subscriptions);\n    if (process.env.NODE_ENV === \"test\") {\n      const updateCounters = currentPolls.pollUpdateCounters ??= {};\n      updateCounters[queryCacheKey] ??= 0;\n      updateCounters[queryCacheKey]++;\n    }\n    if (!Number.isFinite(lowestPollingInterval)) {\n      cleanupPollForKey(queryCacheKey);\n      return;\n    }\n    const currentPoll = currentPolls.get(queryCacheKey);\n    const nextPollTimestamp = Date.now() + lowestPollingInterval;\n    if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {\n      startNextPoll({\n        queryCacheKey\n      }, api2);\n    }\n  }\n  function cleanupPollForKey(key) {\n    const existingPoll = currentPolls.get(key);\n    if (existingPoll?.timeout) {\n      clearTimeout(existingPoll.timeout);\n    }\n    currentPolls.delete(key);\n  }\n  function clearPolls() {\n    for (const key of currentPolls.keys()) {\n      cleanupPollForKey(key);\n    }\n  }\n  function findLowestPollingInterval(subscribers = /* @__PURE__ */ new Map()) {\n    let skipPollingIfUnfocused = false;\n    let lowestPollingInterval = Number.POSITIVE_INFINITY;\n    for (const entry of subscribers.values()) {\n      if (!!entry.pollingInterval) {\n        lowestPollingInterval = Math.min(entry.pollingInterval, lowestPollingInterval);\n        skipPollingIfUnfocused = entry.skipPollingIfUnfocused || skipPollingIfUnfocused;\n      }\n    }\n    return {\n      lowestPollingInterval,\n      skipPollingIfUnfocused\n    };\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/queryLifecycle.ts\nvar buildQueryLifecycleHandler = ({\n  api,\n  context,\n  queryThunk,\n  mutationThunk\n}) => {\n  const isPendingThunk = isPending(queryThunk, mutationThunk);\n  const isRejectedThunk = isRejected(queryThunk, mutationThunk);\n  const isFullfilledThunk = isFulfilled(queryThunk, mutationThunk);\n  const lifecycleMap = {};\n  const handler = (action, mwApi) => {\n    if (isPendingThunk(action)) {\n      const {\n        requestId,\n        arg: {\n          endpointName,\n          originalArgs\n        }\n      } = action.meta;\n      const endpointDefinition = context.endpointDefinitions[endpointName];\n      const onQueryStarted = endpointDefinition?.onQueryStarted;\n      if (onQueryStarted) {\n        const lifecycle = {};\n        const queryFulfilled = new Promise((resolve, reject) => {\n          lifecycle.resolve = resolve;\n          lifecycle.reject = reject;\n        });\n        queryFulfilled.catch(() => {\n        });\n        lifecycleMap[requestId] = lifecycle;\n        const selector = api.endpoints[endpointName].select(isAnyQueryDefinition(endpointDefinition) ? originalArgs : requestId);\n        const extra = mwApi.dispatch((_, __, extra2) => extra2);\n        const lifecycleApi = {\n          ...mwApi,\n          getCacheEntry: () => selector(mwApi.getState()),\n          requestId,\n          extra,\n          updateCachedData: isAnyQueryDefinition(endpointDefinition) ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,\n          queryFulfilled\n        };\n        onQueryStarted(originalArgs, lifecycleApi);\n      }\n    } else if (isFullfilledThunk(action)) {\n      const {\n        requestId,\n        baseQueryMeta\n      } = action.meta;\n      lifecycleMap[requestId]?.resolve({\n        data: action.payload,\n        meta: baseQueryMeta\n      });\n      delete lifecycleMap[requestId];\n    } else if (isRejectedThunk(action)) {\n      const {\n        requestId,\n        rejectedWithValue,\n        baseQueryMeta\n      } = action.meta;\n      lifecycleMap[requestId]?.reject({\n        error: action.payload ?? action.error,\n        isUnhandledError: !rejectedWithValue,\n        meta: baseQueryMeta\n      });\n      delete lifecycleMap[requestId];\n    }\n  };\n  return handler;\n};\n\n// src/query/core/buildMiddleware/windowEventHandling.ts\nvar buildWindowEventHandler = ({\n  reducerPath,\n  context,\n  api,\n  refetchQuery,\n  internalState\n}) => {\n  const {\n    removeQueryResult\n  } = api.internalActions;\n  const handler = (action, mwApi) => {\n    if (onFocus.match(action)) {\n      refetchValidQueries(mwApi, \"refetchOnFocus\");\n    }\n    if (onOnline.match(action)) {\n      refetchValidQueries(mwApi, \"refetchOnReconnect\");\n    }\n  };\n  function refetchValidQueries(api2, type) {\n    const state = api2.getState()[reducerPath];\n    const queries = state.queries;\n    const subscriptions = internalState.currentSubscriptions;\n    context.batch(() => {\n      for (const queryCacheKey of subscriptions.keys()) {\n        const querySubState = queries[queryCacheKey];\n        const subscriptionSubState = subscriptions.get(queryCacheKey);\n        if (!subscriptionSubState || !querySubState) continue;\n        const values = [...subscriptionSubState.values()];\n        const shouldRefetch = values.some((sub) => sub[type] === true) || values.every((sub) => sub[type] === void 0) && state.config[type];\n        if (shouldRefetch) {\n          if (subscriptionSubState.size === 0) {\n            api2.dispatch(removeQueryResult({\n              queryCacheKey\n            }));\n          } else if (querySubState.status !== \"uninitialized\" /* uninitialized */) {\n            api2.dispatch(refetchQuery(querySubState));\n          }\n        }\n      }\n    });\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/index.ts\nfunction buildMiddleware(input) {\n  const {\n    reducerPath,\n    queryThunk,\n    api,\n    context,\n    getInternalState\n  } = input;\n  const {\n    apiUid\n  } = context;\n  const actions = {\n    invalidateTags: createAction(`${reducerPath}/invalidateTags`)\n  };\n  const isThisApiSliceAction = (action) => action.type.startsWith(`${reducerPath}/`);\n  const handlerBuilders = [buildDevCheckHandler, buildCacheCollectionHandler, buildInvalidationByTagsHandler, buildPollingHandler, buildCacheLifecycleHandler, buildQueryLifecycleHandler];\n  const middleware = (mwApi) => {\n    let initialized2 = false;\n    const internalState = getInternalState(mwApi.dispatch);\n    const builderArgs = {\n      ...input,\n      internalState,\n      refetchQuery,\n      isThisApiSliceAction,\n      mwApi\n    };\n    const handlers = handlerBuilders.map((build) => build(builderArgs));\n    const batchedActionsHandler = buildBatchedActionsHandler(builderArgs);\n    const windowEventsHandler = buildWindowEventHandler(builderArgs);\n    return (next) => {\n      return (action) => {\n        if (!isAction(action)) {\n          return next(action);\n        }\n        if (!initialized2) {\n          initialized2 = true;\n          mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n        }\n        const mwApiWithNext = {\n          ...mwApi,\n          next\n        };\n        const stateBefore = mwApi.getState();\n        const [actionShouldContinue, internalProbeResult] = batchedActionsHandler(action, mwApiWithNext, stateBefore);\n        let res;\n        if (actionShouldContinue) {\n          res = next(action);\n        } else {\n          res = internalProbeResult;\n        }\n        if (!!mwApi.getState()[reducerPath]) {\n          windowEventsHandler(action, mwApiWithNext, stateBefore);\n          if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {\n            for (const handler of handlers) {\n              handler(action, mwApiWithNext, stateBefore);\n            }\n          }\n        }\n        return res;\n      };\n    };\n  };\n  return {\n    middleware,\n    actions\n  };\n  function refetchQuery(querySubState) {\n    return input.api.endpoints[querySubState.endpointName].initiate(querySubState.originalArgs, {\n      subscribe: false,\n      forceRefetch: true\n    });\n  }\n}\n\n// src/query/core/module.ts\nvar coreModuleName = /* @__PURE__ */ Symbol();\nvar coreModule = ({\n  createSelector: createSelector2 = createSelector\n} = {}) => ({\n  name: coreModuleName,\n  init(api, {\n    baseQuery,\n    tagTypes,\n    reducerPath,\n    serializeQueryArgs,\n    keepUnusedDataFor,\n    refetchOnMountOrArgChange,\n    refetchOnFocus,\n    refetchOnReconnect,\n    invalidationBehavior,\n    onSchemaFailure,\n    catchSchemaFailure,\n    skipSchemaValidation\n  }, context) {\n    enablePatches();\n    assertCast(serializeQueryArgs);\n    const assertTagType = (tag) => {\n      if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n        if (!tagTypes.includes(tag.type)) {\n          console.error(`Tag type '${tag.type}' was used, but not specified in \\`tagTypes\\`!`);\n        }\n      }\n      return tag;\n    };\n    Object.assign(api, {\n      reducerPath,\n      endpoints: {},\n      internalActions: {\n        onOnline,\n        onOffline,\n        onFocus,\n        onFocusLost\n      },\n      util: {}\n    });\n    const selectors = buildSelectors({\n      serializeQueryArgs,\n      reducerPath,\n      createSelector: createSelector2\n    });\n    const {\n      selectInvalidatedBy,\n      selectCachedArgsForQuery,\n      buildQuerySelector,\n      buildInfiniteQuerySelector,\n      buildMutationSelector\n    } = selectors;\n    safeAssign(api.util, {\n      selectInvalidatedBy,\n      selectCachedArgsForQuery\n    });\n    const {\n      queryThunk,\n      infiniteQueryThunk,\n      mutationThunk,\n      patchQueryData,\n      updateQueryData,\n      upsertQueryData,\n      prefetch,\n      buildMatchThunkActions\n    } = buildThunks({\n      baseQuery,\n      reducerPath,\n      context,\n      api,\n      serializeQueryArgs,\n      assertTagType,\n      selectors,\n      onSchemaFailure,\n      catchSchemaFailure,\n      skipSchemaValidation\n    });\n    const {\n      reducer,\n      actions: sliceActions\n    } = buildSlice({\n      context,\n      queryThunk,\n      infiniteQueryThunk,\n      mutationThunk,\n      serializeQueryArgs,\n      reducerPath,\n      assertTagType,\n      config: {\n        refetchOnFocus,\n        refetchOnReconnect,\n        refetchOnMountOrArgChange,\n        keepUnusedDataFor,\n        reducerPath,\n        invalidationBehavior\n      }\n    });\n    safeAssign(api.util, {\n      patchQueryData,\n      updateQueryData,\n      upsertQueryData,\n      prefetch,\n      resetApiState: sliceActions.resetApiState,\n      upsertQueryEntries: sliceActions.cacheEntriesUpserted\n    });\n    safeAssign(api.internalActions, sliceActions);\n    const internalStateMap = /* @__PURE__ */ new WeakMap();\n    const getInternalState = (dispatch) => {\n      const state = getOrInsertComputed(internalStateMap, dispatch, () => ({\n        currentSubscriptions: /* @__PURE__ */ new Map(),\n        currentPolls: /* @__PURE__ */ new Map(),\n        runningQueries: /* @__PURE__ */ new Map(),\n        runningMutations: /* @__PURE__ */ new Map()\n      }));\n      return state;\n    };\n    const {\n      buildInitiateQuery,\n      buildInitiateInfiniteQuery,\n      buildInitiateMutation,\n      getRunningMutationThunk,\n      getRunningMutationsThunk,\n      getRunningQueriesThunk,\n      getRunningQueryThunk\n    } = buildInitiate({\n      queryThunk,\n      mutationThunk,\n      infiniteQueryThunk,\n      api,\n      serializeQueryArgs,\n      context,\n      getInternalState\n    });\n    safeAssign(api.util, {\n      getRunningMutationThunk,\n      getRunningMutationsThunk,\n      getRunningQueryThunk,\n      getRunningQueriesThunk\n    });\n    const {\n      middleware,\n      actions: middlewareActions\n    } = buildMiddleware({\n      reducerPath,\n      context,\n      queryThunk,\n      mutationThunk,\n      infiniteQueryThunk,\n      api,\n      assertTagType,\n      selectors,\n      getRunningQueryThunk,\n      getInternalState\n    });\n    safeAssign(api.util, middlewareActions);\n    safeAssign(api, {\n      reducer,\n      middleware\n    });\n    return {\n      name: coreModuleName,\n      injectEndpoint(endpointName, definition) {\n        const anyApi = api;\n        const endpoint = anyApi.endpoints[endpointName] ??= {};\n        if (isQueryDefinition(definition)) {\n          safeAssign(endpoint, {\n            name: endpointName,\n            select: buildQuerySelector(endpointName, definition),\n            initiate: buildInitiateQuery(endpointName, definition)\n          }, buildMatchThunkActions(queryThunk, endpointName));\n        }\n        if (isMutationDefinition(definition)) {\n          safeAssign(endpoint, {\n            name: endpointName,\n            select: buildMutationSelector(),\n            initiate: buildInitiateMutation(endpointName)\n          }, buildMatchThunkActions(mutationThunk, endpointName));\n        }\n        if (isInfiniteQueryDefinition(definition)) {\n          safeAssign(endpoint, {\n            name: endpointName,\n            select: buildInfiniteQuerySelector(endpointName, definition),\n            initiate: buildInitiateInfiniteQuery(endpointName, definition)\n          }, buildMatchThunkActions(queryThunk, endpointName));\n        }\n      }\n    };\n  }\n});\n\n// src/query/core/index.ts\nvar createApi = /* @__PURE__ */ buildCreateApi(coreModule());\nexport {\n  NamedSchemaError,\n  QueryStatus,\n  _NEVER,\n  buildCreateApi,\n  copyWithStructuralSharing,\n  coreModule,\n  coreModuleName,\n  createApi,\n  defaultSerializeQueryArgs,\n  fakeBaseQuery,\n  fetchBaseQuery,\n  retry,\n  setupListeners,\n  skipToken\n};\n//# sourceMappingURL=rtk-query.modern.mjs.map"],"mappings":";;;AAsBA,IAAI,cAAc,cAAc,MAAM;;;;CAIpC;;;;;;CAMA,YAAY,QAAQ;AAClB,QAAM,OAAO,GAAG,QAAQ;AACxB,OAAK,OAAO;AACZ,OAAK,SAAS;;;;;;AClClB,IAAI,cAA8B,kBAAE,iBAAiB;AACnD,cAAa,mBAAmB;AAChC,cAAa,aAAa;AAC1B,cAAa,eAAe;AAC5B,cAAa,cAAc;AAC3B,QAAO;GACN,eAAe,EAAE,CAAC;AACrB,SAAS,sBAAsB,QAAQ;AACrC,QAAO;EACL;EACA,iBAAiB,WAAW;EAC5B,WAAW,WAAW;EACtB,WAAW,WAAW;EACtB,SAAS,WAAW;EACrB;;AAOH,IAAI,iBAAiB;AACrB,SAAS,0BAA0B,QAAQ,QAAQ;AACjD,KAAI,WAAW,UAAU,EAAE,eAAe,OAAO,IAAI,eAAe,OAAO,IAAI,MAAM,QAAQ,OAAO,IAAI,MAAM,QAAQ,OAAO,EAC3H,QAAO;CAET,MAAM,UAAU,OAAO,KAAK,OAAO;CACnC,MAAM,UAAU,OAAO,KAAK,OAAO;CACnC,IAAI,eAAe,QAAQ,WAAW,QAAQ;CAC9C,MAAM,WAAW,MAAM,QAAQ,OAAO,GAAG,EAAE,GAAG,EAAE;AAChD,MAAK,MAAM,OAAO,SAAS;AACzB,WAAS,OAAO,0BAA0B,OAAO,MAAM,OAAO,KAAK;AACnE,MAAI,aAAc,gBAAe,OAAO,SAAS,SAAS;;AAE5D,QAAO,eAAe,SAAS;;AAIjC,IAAI,WAAW,QAAQ,EAAE,CAAC,OAAO,GAAG,IAAI;AAGxC,SAAS,cAAc,KAAK;AAC1B,yBAAO,IAAI,OAAO,UAAU,EAAC,KAAK,IAAI;;AAIxC,SAAS,oBAAoB;AAC3B,KAAI,OAAO,aAAa,YACtB,QAAO;AAET,QAAO,SAAS,oBAAoB;;AAItC,SAAS,aAAa,GAAG;AACvB,QAAO,KAAK;;AAEd,SAAS,oBAAoB,KAAK;AAChC,QAAO,CAAC,GAAG,KAAK,QAAQ,IAAI,EAAE,CAAC,CAAC,OAAO,aAAa;;AAItD,SAAS,WAAW;AAClB,QAAO,OAAO,cAAc,cAAc,OAAO,UAAU,WAAW,KAAK,IAAI,OAAO,UAAU;;AAIlG,IAAI,wBAAwB,QAAQ,IAAI,QAAQ,OAAO,GAAG;AAC1D,IAAI,uBAAuB,QAAQ,IAAI,QAAQ,OAAO,GAAG;AACzD,SAAS,SAAS,MAAM,KAAK;AAC3B,KAAI,CAAC,KACH,QAAO;AAET,KAAI,CAAC,IACH,QAAO;AAET,KAAI,cAAc,IAAI,CACpB,QAAO;CAET,MAAM,YAAY,KAAK,SAAS,IAAI,IAAI,CAAC,IAAI,WAAW,IAAI,GAAG,MAAM;AACrE,QAAO,qBAAqB,KAAK;AACjC,OAAM,oBAAoB,IAAI;AAC9B,QAAO,GAAG,OAAO,YAAY;;AAI/B,SAAS,oBAAoB,KAAK,KAAK,SAAS;AAC9C,KAAI,IAAI,IAAI,IAAI,CAAE,QAAO,IAAI,IAAI,IAAI;AACrC,QAAO,IAAI,IAAI,KAAK,QAAQ,IAAI,CAAC,CAAC,IAAI,IAAI;;AAE5C,IAAI,qCAAqC,IAAI,KAAK;AAGlD,IAAI,kBAAkB,GAAG,SAAS,MAAM,GAAG,KAAK;AAChD,IAAI,yBAAyB,aAAa,SAAS,UAAU,OAAO,SAAS,UAAU;AACvF,IAAI,4BAA4B,YAE9B,yBAAyB,KAAK,QAAQ,IAAI,eAAe,IAAI,GAAG;AAElE,SAAS,eAAe,KAAK;AAC3B,KAAI,CAAC,cAAc,IAAI,CACrB,QAAO;CAET,MAAM,OAAO,EACX,GAAG,KACJ;AACD,MAAK,MAAM,CAAC,GAAG,MAAM,OAAO,QAAQ,KAAK,CACvC,KAAI,MAAM,KAAK,EAAG,QAAO,KAAK;AAEhC,QAAO;;AAET,IAAI,iBAAiB,SAAS,OAAO,SAAS,aAAa,cAAc,KAAK,IAAI,MAAM,QAAQ,KAAK,IAAI,OAAO,KAAK,WAAW;AAChI,SAAS,eAAe,EACtB,SACA,kBAAkB,MAAM,GACxB,UAAU,gBACV,kBACA,oBAAoB,0BACpB,kBAAkB,oBAClB,cACA,SAAS,gBACT,iBAAiB,uBACjB,gBAAgB,qBAChB,GAAG,qBACD,EAAE,EAAE;AACN,KAAI,OAAO,UAAU,eAAe,YAAY,eAC9C,SAAQ,KAAK,4HAA4H;AAE3I,QAAO,OAAO,KAAK,KAAK,iBAAiB;EACvC,MAAM,EACJ,UACA,OACA,UACA,QACA,SACE;EACJ,IAAI;EACJ,IAAI,EACF,KACA,UAAU,IAAI,QAAQ,iBAAiB,QAAQ,EAC/C,SAAS,KAAK,GACd,kBAAkB,yBAAyB,QAC3C,iBAAiB,wBAAwB,uBACzC,UAAU,eACV,GAAG,SACD,OAAO,OAAO,WAAW,EAC3B,KAAK,KACN,GAAG;EACJ,IAAI,iBAAiB,SAAS,IAAI;AAClC,MAAI,SAAS;AACX,qBAAkB,IAAI,iBAAiB;AACvC,OAAI,OAAO,iBAAiB,SAAS,gBAAgB,MAAM;AAC3D,YAAS,gBAAgB;;EAE3B,IAAI,SAAS;GACX,GAAG;GACH;GACA,GAAG;GACJ;AACD,YAAU,IAAI,QAAQ,eAAe,QAAQ,CAAC;AAC9C,SAAO,UAAU,MAAM,eAAe,SAAS;GAC7C;GACA;GACA;GACA;GACA;GACA;GACA;GACD,CAAC,IAAI;EACN,MAAM,oBAAoB,cAAc,OAAO,KAAK;AACpD,MAAI,OAAO,QAAQ,QAAQ,CAAC,qBAAqB,OAAO,OAAO,SAAS,SACtE,QAAO,QAAQ,OAAO,eAAe;AAEvC,MAAI,CAAC,OAAO,QAAQ,IAAI,eAAe,IAAI,kBACzC,QAAO,QAAQ,IAAI,gBAAgB,gBAAgB;AAErD,MAAI,qBAAqB,kBAAkB,OAAO,QAAQ,CACxD,QAAO,OAAO,KAAK,UAAU,OAAO,MAAM,aAAa;AAEzD,MAAI,CAAC,OAAO,QAAQ,IAAI,SAAS,EAC/B;OAAI,oBAAoB,OACtB,QAAO,QAAQ,IAAI,UAAU,mBAAmB;YACvC,oBAAoB,OAC7B,QAAO,QAAQ,IAAI,UAAU,6BAA6B;;AAG9D,MAAI,QAAQ;GACV,MAAM,UAAU,CAAC,IAAI,QAAQ,IAAI,GAAG,MAAM;GAC1C,MAAM,QAAQ,mBAAmB,iBAAiB,OAAO,GAAG,IAAI,gBAAgB,eAAe,OAAO,CAAC;AACvG,UAAO,UAAU;;AAEnB,QAAM,SAAS,SAAS,IAAI;EAC5B,MAAM,UAAU,IAAI,QAAQ,KAAK,OAAO;AAExC,SAAO,EACL,SAFmB,IAAI,QAAQ,KAAK,OAAO,EAG5C;EACD,IAAI,UAAU,WAAW,OAAO,YAAY,mBAAmB,iBAAiB;AAC9E,cAAW;AACX,mBAAgB,OAAO;KACtB,QAAQ;AACX,MAAI;AACF,cAAW,MAAM,QAAQ,QAAQ;WAC1B,GAAG;AACV,UAAO;IACL,OAAO;KACL,QAAQ,WAAW,kBAAkB;KACrC,OAAO,OAAO,EAAE;KACjB;IACD;IACD;YACO;AACR,OAAI,UAAW,cAAa,UAAU;AACtC,oBAAiB,OAAO,oBAAoB,SAAS,gBAAgB,MAAM;;EAE7E,MAAM,gBAAgB,SAAS,OAAO;AACtC,OAAK,WAAW;EAChB,IAAI;EACJ,IAAI,eAAe;AACnB,MAAI;GACF,IAAI;AACJ,SAAM,QAAQ,IAAI,CAChB,eAAe,UAAU,gBAAgB,CAAC,MAAM,MAAM,aAAa,IAAI,MAAM,sBAAsB,EAAE,EAGrG,cAAc,MAAM,CAAC,MAAM,MAAM,eAAe,SAAS,GACvD,CACH,CAAC;AACF,OAAI,oBAAqB,OAAM;WACxB,GAAG;AACV,UAAO;IACL,OAAO;KACL,QAAQ;KACR,gBAAgB,SAAS;KACzB,MAAM;KACN,OAAO,OAAO,EAAE;KACjB;IACD;IACD;;AAEH,SAAO,eAAe,UAAU,WAAW,GAAG;GAC5C,MAAM;GACN;GACD,GAAG;GACF,OAAO;IACL,QAAQ,SAAS;IACjB,MAAM;IACP;GACD;GACD;;CAEH,eAAe,eAAe,UAAU,iBAAiB;AACvD,MAAI,OAAO,oBAAoB,WAC7B,QAAO,gBAAgB,SAAS;AAElC,MAAI,oBAAoB,eACtB,mBAAkB,kBAAkB,SAAS,QAAQ,GAAG,SAAS;AAEnE,MAAI,oBAAoB,QAAQ;GAC9B,MAAM,OAAO,MAAM,SAAS,MAAM;AAClC,UAAO,KAAK,SAAS,KAAK,MAAM,KAAK,GAAG;;AAE1C,SAAO,SAAS,MAAM;;;AAK1B,IAAI,eAAe,MAAM;CACvB,YAAY,OAAO,OAAO,KAAK,GAAG;AAChC,OAAK,QAAQ;AACb,OAAK,OAAO;;;AAKhB,eAAe,eAAe,UAAU,GAAG,aAAa,GAAG,QAAQ;CACjE,MAAM,WAAW,KAAK,IAAI,SAAS,WAAW;CAC9C,MAAM,UAAU,CAAC,GAAG,KAAK,QAAQ,GAAG,OAAQ,OAAO;AACnD,OAAM,IAAI,SAAS,SAAS,WAAW;EACrC,MAAM,YAAY,iBAAiB,SAAS,EAAE,QAAQ;AACtD,MAAI,QAAQ;GACV,MAAM,qBAAqB;AACzB,iBAAa,UAAU;AACvB,2BAAO,IAAI,MAAM,UAAU,CAAC;;AAE9B,OAAI,OAAO,SAAS;AAClB,iBAAa,UAAU;AACvB,2BAAO,IAAI,MAAM,UAAU,CAAC;SAE5B,QAAO,iBAAiB,SAAS,cAAc,EAC7C,MAAM,MACP,CAAC;;GAGN;;AAEJ,SAAS,KAAK,OAAO,MAAM;AACzB,OAAM,OAAO,OAAO,IAAI,aAAa;EACnC;EACA;EACD,CAAC,EAAE,EACF,kBAAkB,MACnB,CAAC;;AAEJ,SAAS,cAAc,QAAQ;AAC7B,KAAI,OAAO,QACT,MAAK;EACH,QAAQ;EACR,OAAO;EACR,CAAC;;AAGN,IAAI,gBAAgB,EAAE;AACtB,IAAI,oBAAoB,WAAW,mBAAmB,OAAO,MAAM,KAAK,iBAAiB;CAEvF,MAAM,CAAC,cADoB;EAAC;GAAI,kBAAkB,eAAe;GAAa,gBAAgB,eAAe;EAAW,CAAC,QAAQ,MAAM,MAAM,KAAK,EAAE,CAC5G,MAAM,GAAG;CACjD,MAAM,yBAAyB,GAAG,IAAI,EACpC,cACI,WAAW;CACjB,MAAM,UAAU;EACd;EACA,SAAS;EACT,gBAAgB;EAChB,GAAG;EACH,GAAG;EACJ;CACD,IAAI,SAAS;AACb,QAAO,MAAM;AACX,gBAAc,IAAI,OAAO;AACzB,MAAI;GACF,MAAM,SAAS,MAAM,UAAU,MAAM,KAAK,aAAa;AACvD,OAAI,OAAO,MACT,OAAM,IAAI,aAAa,OAAO;AAEhC,UAAO;WACA,GAAG;AACV;AACA,OAAI,EAAE,kBAAkB;AACtB,QAAI,aAAa,aACf,QAAO,EAAE;AAEX,UAAM;;AAER,OAAI,aAAa,cACf;QAAI,CAAC,QAAQ,eAAe,EAAE,MAAM,OAAO,MAAM;KAC/C,SAAS;KACT,cAAc;KACd;KACD,CAAC,CACA,QAAO,EAAE;cAGP,SAAS,QAAQ,WACnB,QAAO,EACL,OAAO,GACR;AAGL,iBAAc,IAAI,OAAO;AACzB,OAAI;AACF,UAAM,QAAQ,QAAQ,QAAQ,QAAQ,YAAY,IAAI,OAAO;YACtD,cAAc;AACrB,kBAAc,IAAI,OAAO;AACzB,UAAM;;;;;AAKd,IAAI,QAAwB,uBAAO,OAAO,kBAAkB,EAC1D,MACD,CAAC;AAGF,IAAI,UAA0B,6BAAa,iBAAiB;AAC5D,IAAI,cAA8B,6BAAa,mBAAmB;AAClE,IAAI,WAA2B,6BAAa,gBAAgB;AAC5D,IAAI,YAA4B,6BAAa,iBAAiB;AAC9D,IAAI,cAAc;AAClB,SAAS,eAAe,UAAU,eAAe;CAC/C,SAAS,iBAAiB;EACxB,MAAM,oBAAoB,SAAS,SAAS,CAAC;EAC7C,MAAM,wBAAwB,SAAS,aAAa,CAAC;EACrD,MAAM,qBAAqB,SAAS,UAAU,CAAC;EAC/C,MAAM,sBAAsB,SAAS,WAAW,CAAC;EACjD,MAAM,+BAA+B;AACnC,OAAI,OAAO,SAAS,oBAAoB,UACtC,cAAa;OAEb,kBAAiB;;AAGrB,MAAI,CAAC,aACH;OAAI,OAAO,WAAW,eAAe,OAAO,kBAAkB;AAC5D,WAAO,iBAAiB,oBAAoB,wBAAwB,MAAM;AAC1E,WAAO,iBAAiB,SAAS,aAAa,MAAM;AACpD,WAAO,iBAAiB,UAAU,cAAc,MAAM;AACtD,WAAO,iBAAiB,WAAW,eAAe,MAAM;AACxD,kBAAc;;;EAGlB,MAAM,oBAAoB;AACxB,UAAO,oBAAoB,SAAS,YAAY;AAChD,UAAO,oBAAoB,oBAAoB,uBAAuB;AACtE,UAAO,oBAAoB,UAAU,aAAa;AAClD,UAAO,oBAAoB,WAAW,cAAc;AACpD,iBAAc;;AAEhB,SAAO;;AAET,QAAO,gBAAgB,cAAc,UAAU;EAC7C;EACA;EACA;EACA;EACD,CAAC,GAAG,gBAAgB;;AAIvB,SAAS,kBAAkB,GAAG;AAC5B,QAAO,EAAE,SAAS;;AAEpB,SAAS,qBAAqB,GAAG;AAC/B,QAAO,EAAE,SAAS;;AAEpB,SAAS,0BAA0B,GAAG;AACpC,QAAO,EAAE,SAAS;;AAEpB,SAAS,qBAAqB,GAAG;AAC/B,QAAO,kBAAkB,EAAE,IAAI,0BAA0B,EAAE;;AAE7D,SAAS,oBAAoB,aAAa,QAAQ,OAAO,UAAU,MAAM,gBAAgB;AACvF,KAAI,WAAW,YAAY,CACzB,QAAO,YAAY,QAAQ,OAAO,UAAU,KAAK,CAAC,OAAO,aAAa,CAAC,IAAI,qBAAqB,CAAC,IAAI,eAAe;AAEtH,KAAI,MAAM,QAAQ,YAAY,CAC5B,QAAO,YAAY,IAAI,qBAAqB,CAAC,IAAI,eAAe;AAElE,QAAO,EAAE;;AAEX,SAAS,WAAW,GAAG;AACrB,QAAO,OAAO,MAAM;;AAEtB,SAAS,qBAAqB,aAAa;AACzC,QAAO,OAAO,gBAAgB,WAAW,EACvC,MAAM,aACP,GAAG;;AAUN,SAAS,cAAc,SAAS,UAAU;AACxC,QAAO,QAAQ,MAAM,SAAS;;AAIhC,IAAI,qBAAqB,OAAO,eAAe;AAC/C,IAAI,iBAAiB,QAAQ,OAAO,IAAI,wBAAwB;AAChE,SAAS,cAAc,EACrB,oBACA,YACA,oBACA,eACA,KACA,SACA,oBACC;CACD,MAAM,qBAAqB,aAAa,iBAAiB,SAAS,EAAE;CACpE,MAAM,uBAAuB,aAAa,iBAAiB,SAAS,EAAE;CACtE,MAAM,EACJ,wBACA,sBACA,8BACE,IAAI;AACR,QAAO;EACL;EACA;EACA;EACA;EACA;EACA;EACA;EACD;CACD,SAAS,qBAAqB,cAAc,WAAW;AACrD,UAAQ,aAAa;GACnB,MAAM,qBAAqB,QAAQ,oBAAoB;GACvD,MAAM,gBAAgB,mBAAmB;IACvC;IACA;IACA;IACD,CAAC;AACF,UAAO,kBAAkB,SAAS,EAAE,IAAI,cAAc;;;CAG1D,SAAS,wBAAwB,eAAe,0BAA0B;AACxE,UAAQ,aAAa;AACnB,UAAO,oBAAoB,SAAS,EAAE,IAAI,yBAAyB;;;CAGvE,SAAS,yBAAyB;AAChC,UAAQ,aAAa,oBAAoB,kBAAkB,SAAS,CAAC;;CAEvE,SAAS,2BAA2B;AAClC,UAAQ,aAAa,oBAAoB,oBAAoB,SAAS,CAAC;;CAEzE,SAAS,kBAAkB,UAAU;EACQ;AACzC,OAAI,kBAAkB,UAAW;GACjC,MAAM,gBAAgB,SAAS,IAAI,gBAAgB,+BAA+B,CAAC;AACnF,qBAAkB,YAAY;AAC9B,OAAI,OAAO,kBAAkB,YAAY,OAAO,eAAe,SAAS,SACtE,OAAM,IAAI,MAA4E,yDAAyD,IAAI,YAAY;kEACrG;;;CAIhE,SAAS,sBAAsB,cAAc,oBAAoB;EAC/D,MAAM,eAAe,KAAK,EACxB,YAAY,MACZ,cACA,sBACC,qBAAqB,aACtB,GAAG,SACD,EAAE,MAAM,UAAU,aAAa;GACjC,MAAM,gBAAgB,mBAAmB;IACvC,WAAW;IACX;IACA;IACD,CAAC;GACF,IAAI;GACJ,MAAM,kBAAkB;IACtB,GAAG;IACH,MAAM;IACN;IACA;IACA;IACA;IACA,cAAc;IACd;KACC,qBAAqB;IACvB;AACD,OAAI,kBAAkB,mBAAmB,CACvC,SAAQ,WAAW,gBAAgB;QAC9B;IACL,MAAM,EACJ,WACA,qBACE;AACJ,YAAQ,mBAAmB;KACzB,GAAG;KAGH;KACA;KACD,CAAC;;GAEJ,MAAM,WAAW,IAAI,UAAU,cAAc,OAAO,IAAI;GACxD,MAAM,cAAc,SAAS,MAAM;GACnC,MAAM,aAAa,SAAS,UAAU,CAAC;AACvC,qBAAkB,SAAS;GAC3B,MAAM,EACJ,WACA,UACE;GACJ,MAAM,uBAAuB,WAAW,cAAc;GACtD,MAAM,eAAe,kBAAkB,SAAS,EAAE,IAAI,cAAc;GACpE,MAAM,wBAAwB,SAAS,UAAU,CAAC;GAClD,MAAM,eAAe,OAAO,OAAO,eAGjC,YAAY,KAAK,gBAAgB,GAC/B,wBAAwB,CAAC,eAG3B,QAAQ,QAAQ,WAAW,GAI3B,QAAQ,IAAI,CAAC,cAAc,YAAY,CAAC,CAAC,KAAK,gBAAgB,EAC7D;IACD;IACA;IACA;IACA;IACA;IACA,MAAM,SAAS;KACb,MAAM,SAAS,MAAM;AACrB,SAAI,OAAO,QACT,OAAM,OAAO;AAEf,YAAO,OAAO;;IAEhB,eAAe,SAAS,YAAY,KAAK;KACvC,WAAW;KACX,cAAc;KACf,CAAC,CAAC;IACH,cAAc;AACZ,SAAI,UAAW,UAAS,uBAAuB;MAC7C;MACA;MACD,CAAC,CAAC;;IAEL,0BAA0B,SAAS;AACjC,kBAAa,sBAAsB;AACnC,cAAS,0BAA0B;MACjC;MACA;MACA;MACA;MACD,CAAC,CAAC;;IAEN,CAAC;AACF,OAAI,CAAC,gBAAgB,CAAC,wBAAwB,CAAC,cAAc;IAC3D,MAAM,iBAAiB,kBAAkB,SAAS;AAClD,mBAAe,IAAI,eAAe,aAAa;AAC/C,iBAAa,WAAW;AACtB,oBAAe,OAAO,cAAc;MACpC;;AAEJ,UAAO;;AAET,SAAO;;CAET,SAAS,mBAAmB,cAAc,oBAAoB;AAE5D,SADoB,sBAAsB,cAAc,mBAAmB;;CAG7E,SAAS,2BAA2B,cAAc,oBAAoB;AAEpE,SAD4B,sBAAsB,cAAc,mBAAmB;;CAGrF,SAAS,sBAAsB,cAAc;AAC3C,UAAQ,KAAK,EACX,QAAQ,MACR,kBACE,EAAE,MAAM,UAAU,aAAa;GACjC,MAAM,QAAQ,cAAc;IAC1B,MAAM;IACN;IACA,cAAc;IACd;IACA;IACD,CAAC;GACF,MAAM,cAAc,SAAS,MAAM;AACnC,qBAAkB,SAAS;GAC3B,MAAM,EACJ,WACA,OACA,WACE;GACJ,MAAM,qBAAqB,cAAc,YAAY,QAAQ,CAAC,MAAM,UAAU,EAC5E,MACD,EAAE,GAAG,WAAW,EACf,OACD,EAAE;GACH,MAAM,cAAc;AAClB,aAAS,qBAAqB;KAC5B;KACA;KACD,CAAC,CAAC;;GAEL,MAAM,MAAM,OAAO,OAAO,oBAAoB;IAC5C,KAAK,YAAY;IACjB;IACA;IACA;IACA;IACD,CAAC;GACF,MAAM,mBAAmB,oBAAoB,SAAS;AACtD,oBAAiB,IAAI,WAAW,IAAI;AACpC,OAAI,WAAW;AACb,qBAAiB,OAAO,UAAU;KAClC;AACF,OAAI,eAAe;AACjB,qBAAiB,IAAI,eAAe,IAAI;AACxC,QAAI,WAAW;AACb,SAAI,iBAAiB,IAAI,cAAc,KAAK,IAC1C,kBAAiB,OAAO,cAAc;MAExC;;AAEJ,UAAO;;;;AAOb,IAAI,mBAAmB,cAAc,YAAY;CAC/C,YAAY,QAAQ,OAAO,YAAY,SAAS;AAC9C,QAAM,OAAO;AACb,OAAK,QAAQ;AACb,OAAK,aAAa;AAClB,OAAK,UAAU;;;AAGnB,IAAI,cAAc,sBAAsB,eAAe,MAAM,QAAQ,qBAAqB,GAAG,qBAAqB,SAAS,WAAW,GAAG,CAAC,CAAC;AAC3I,eAAe,gBAAgB,QAAQ,MAAM,YAAY,QAAQ;CAC/D,MAAM,SAAS,MAAM,OAAO,aAAa,SAAS,KAAK;AACvD,KAAI,OAAO,OACT,OAAM,IAAI,iBAAiB,OAAO,QAAQ,MAAM,YAAY,OAAO;AAErE,QAAO,OAAO;;AAIhB,SAAS,yBAAyB,sBAAsB;AACtD,QAAO;;AAET,IAAI,sBAAsB,MAAM,EAAE,KAAK;AACrC,QAAO;EACL,GAAG;GACF,mBAAmB;EACrB;;AAEH,SAAS,YAAY,EACnB,aACA,WACA,SAAS,EACP,uBAEF,oBACA,KACA,eACA,WACA,iBACA,oBAAoB,0BACpB,sBAAsB,8BACrB;CACD,MAAM,kBAAkB,cAAc,KAAK,SAAS,oBAAoB,UAAU,aAAa;EAC7F,MAAM,qBAAqB,oBAAoB;EAC/C,MAAM,gBAAgB,mBAAmB;GACvC,WAAW;GACX;GACA;GACD,CAAC;AACF,WAAS,IAAI,gBAAgB,mBAAmB;GAC9C;GACA;GACD,CAAC,CAAC;AACH,MAAI,CAAC,eACH;EAEF,MAAM,WAAW,IAAI,UAAU,cAAc,OAAO,IAAI,CAEtD,UAAU,CACX;EACD,MAAM,eAAe,oBAAoB,mBAAmB,cAAc,SAAS,MAAM,KAAK,GAAG,KAAK,EAAE,EAAE,cAAc;AACxH,WAAS,IAAI,gBAAgB,iBAAiB,CAAC;GAC7C;GACA;GACD,CAAC,CAAC,CAAC;;CAEN,SAAS,WAAW,OAAO,MAAM,MAAM,GAAG;EACxC,MAAM,WAAW,CAAC,MAAM,GAAG,MAAM;AACjC,SAAO,OAAO,SAAS,SAAS,MAAM,SAAS,MAAM,GAAG,GAAG,GAAG;;CAEhE,SAAS,SAAS,OAAO,MAAM,MAAM,GAAG;EACtC,MAAM,WAAW,CAAC,GAAG,OAAO,KAAK;AACjC,SAAO,OAAO,SAAS,SAAS,MAAM,SAAS,MAAM,EAAE,GAAG;;CAE5D,MAAM,mBAAmB,cAAc,KAAK,cAAc,iBAAiB,UAAU,UAAU,aAAa;EAE1G,MAAM,eADqB,IAAI,UAAU,cACD,OAAO,IAAI,CAEjD,UAAU,CACX;EACD,MAAM,MAAM;GACV,SAAS,EAAE;GACX,gBAAgB,EAAE;GAClB,YAAY,SAAS,IAAI,KAAK,eAAe,cAAc,KAAK,IAAI,gBAAgB,eAAe,CAAC;GACrG;AACD,MAAI,aAAa,WAAW,gBAC1B,QAAO;EAET,IAAI;AACJ,MAAI,UAAU,aACZ,KAAI,YAAY,aAAa,KAAK,EAAE;GAClC,MAAM,CAAC,OAAO,SAAS,kBAAkB,mBAAmB,aAAa,MAAM,aAAa;AAC5F,OAAI,QAAQ,KAAK,GAAG,QAAQ;AAC5B,OAAI,eAAe,KAAK,GAAG,eAAe;AAC1C,cAAW;SACN;AACL,cAAW,aAAa,aAAa,KAAK;AAC1C,OAAI,QAAQ,KAAK;IACf,IAAI;IACJ,MAAM,EAAE;IACR,OAAO;IACR,CAAC;AACF,OAAI,eAAe,KAAK;IACtB,IAAI;IACJ,MAAM,EAAE;IACR,OAAO,aAAa;IACrB,CAAC;;AAGN,MAAI,IAAI,QAAQ,WAAW,EACzB,QAAO;AAET,WAAS,IAAI,KAAK,eAAe,cAAc,KAAK,IAAI,SAAS,eAAe,CAAC;AACjF,SAAO;;CAET,MAAM,mBAAmB,cAAc,KAAK,WAAW,aAAa;AAQlE,SAPY,SAAS,IAAI,UAAU,cAAc,SAAS,KAAK;GAC7D,WAAW;GACX,cAAc;IACb,4BAA4B,EAC3B,MAAM,OACP;GACF,CAAC,CAAC;;CAGL,MAAM,mCAAmC,oBAAoB,uBAAuB;AAClF,SAAO,mBAAmB,SAAS,mBAAmB,sBAAsB,mBAAmB,sBAAsB;;CAEvH,MAAM,kBAAkB,OAAO,KAAK,EAClC,QACA,OACA,iBACA,kBACA,UACA,UACA,YACI;EACJ,MAAM,qBAAqB,oBAAoB,IAAI;EACnD,MAAM,EACJ,YACA,uBAAuB,+BACrB;AACJ,MAAI;GACF,IAAI,oBAAoB;GACxB,MAAM,eAAe;IACnB;IACA;IACA;IACA;IACA;IACA,UAAU,IAAI;IACd,MAAM,IAAI;IACV,QAAQ,IAAI,SAAS,UAAU,cAAc,KAAK,UAAU,CAAC,GAAG,KAAK;IACrE,eAAe,IAAI,SAAS,UAAU,IAAI,gBAAgB,KAAK;IAChE;GACD,MAAM,eAAe,IAAI,SAAS,UAAU,IAAI,sBAAsB,KAAK;GAC3E,IAAI;GACJ,MAAM,YAAY,OAAO,MAAM,OAAO,UAAU,aAAa;AAC3D,QAAI,SAAS,QAAQ,KAAK,MAAM,OAC9B,QAAO,QAAQ,QAAQ,EACrB,MACD,CAAC;IAEJ,MAAM,gBAAgB;KACpB,UAAU,IAAI;KACd,WAAW;KACZ;IACD,MAAM,eAAe,MAAM,eAAe,cAAc;IACxD,MAAM,QAAQ,WAAW,aAAa;AACtC,WAAO;KACL,MAAM;MACJ,OAAO,MAAM,KAAK,OAAO,aAAa,MAAM,SAAS;MACrD,YAAY,MAAM,KAAK,YAAY,OAAO,SAAS;MACpD;KACD,MAAM,aAAa;KACpB;;GAEH,eAAe,eAAe,eAAe;IAC3C,IAAI;IACJ,MAAM,EACJ,cACA,WACA,mBACA,mBACE;AACJ,QAAI,aAAa,CAAC,WAAW,sBAAsB,MAAM,CACvD,iBAAgB,MAAM,gBACpB,WACA,eACA,aACA,EAAE,CAEH;AAEH,QAAI,aACF,UAAS,cAAc;aACd,mBAAmB,OAAO;AACnC,yBAAoB,gCAAgC,oBAAoB,oBAAoB;AAC5F,cAAS,MAAM,UAAU,mBAAmB,MAAM,cAAc,EAAE,cAAc,aAAa;UAE7F,UAAS,MAAM,mBAAmB,QAAQ,eAAe,cAAc,eAAe,SAAS,UAAU,MAAM,cAAc,aAAa,CAAC;AAE7I,QAAI,OAAO,YAAY,eAAe,MAAwC;KAC5E,MAAM,OAAO,mBAAmB,QAAQ,gBAAgB;KACxD,IAAI;AACJ,SAAI,CAAC,OACH,OAAM,GAAG,KAAK;cACL,OAAO,WAAW,SAC3B,OAAM,GAAG,KAAK;cACL,OAAO,SAAS,OAAO,KAChC,OAAM,GAAG,KAAK;cACL,OAAO,UAAU,KAAK,KAAK,OAAO,SAAS,KAAK,EACzD,OAAM,GAAG,KAAK;SAEd,MAAK,MAAM,OAAO,OAAO,KAAK,OAAO,CACnC,KAAI,QAAQ,WAAW,QAAQ,UAAU,QAAQ,QAAQ;AACvD,YAAM,0BAA0B,KAAK,4BAA4B,IAAI;AACrE;;AAIN,SAAI,IACF,SAAQ,MAAM,2CAA2C,IAAI,aAAa;oBAClE,IAAI;;yCAEiB,OAAO;;AAGxC,QAAI,OAAO,MAAO,OAAM,IAAI,aAAa,OAAO,OAAO,OAAO,KAAK;IACnE,IAAI,EACF,SACE;AACJ,QAAI,qBAAqB,CAAC,WAAW,sBAAsB,cAAc,CACvE,QAAO,MAAM,gBAAgB,mBAAmB,OAAO,MAAM,qBAAqB,OAAO,KAAK;IAEhG,IAAI,sBAAsB,MAAM,kBAAkB,MAAM,OAAO,MAAM,cAAc;AACnF,QAAI,kBAAkB,CAAC,WAAW,sBAAsB,WAAW,CACjE,uBAAsB,MAAM,gBAAgB,gBAAgB,qBAAqB,kBAAkB,OAAO,KAAK;AAEjH,WAAO;KACL,GAAG;KACH,MAAM;KACP;;AAEH,OAAI,IAAI,SAAS,WAAW,0BAA0B,oBAAoB;IACxE,MAAM,EACJ,yBACE;IACJ,MAAM,EACJ,WAAW,aACT;IACJ,IAAI;IACJ,MAAM,YAAY;KAChB,OAAO,EAAE;KACT,YAAY,EAAE;KACf;IACD,MAAM,aAAa,UAAU,iBAAiB,UAAU,EAAE,IAAI,cAAc,EAAE;IAK9E,MAAM,eAFJ,cAAc,KAAK,UAAU,CAAC,IAAI,CAAC,IAAI,aAEW,CAAC,aAAa,YAAY;AAC9E,QAAI,eAAe,OAAO,IAAI,aAAa,aAAa,MAAM,QAAQ;KACpE,MAAM,WAAW,IAAI,cAAc;KAEnC,MAAM,SADc,WAAW,uBAAuB,kBAC5B,sBAAsB,cAAc,IAAI,aAAa;AAC/E,cAAS,MAAM,UAAU,cAAc,OAAO,UAAU,SAAS;WAC5D;KACL,MAAM,EACJ,mBAAmB,qBAAqB,qBACtC;KACJ,MAAM,mBAAmB,YAAY,cAAc,EAAE;KACrD,MAAM,iBAAiB,iBAAiB,MAAM;KAC9C,MAAM,aAAa,iBAAiB;AACpC,cAAS,MAAM,UAAU,cAAc,gBAAgB,SAAS;AAChE,SAAI,aACF,UAAS,EACP,MAAM,OAAO,KAAK,MAAM,IACzB;AAEH,UAAK,IAAI,IAAI,GAAG,IAAI,YAAY,KAAK;MACnC,MAAM,QAAQ,iBAAiB,sBAAsB,OAAO,MAAM,IAAI,aAAa;AACnF,eAAS,MAAM,UAAU,OAAO,MAAM,OAAO,SAAS;;;AAG1D,4BAAwB;SAExB,yBAAwB,MAAM,eAAe,IAAI,aAAa;AAEhE,OAAI,cAAc,CAAC,WAAW,sBAAsB,OAAO,IAAI,sBAAsB,KACnF,uBAAsB,OAAO,MAAM,gBAAgB,YAAY,sBAAsB,MAAM,cAAc,sBAAsB,KAAK;AAEtI,UAAO,iBAAiB,sBAAsB,MAAM,mBAAmB;IACrE,oBAAoB,KAAK,KAAK;IAC9B,eAAe,sBAAsB;IACtC,CAAC,CAAC;WACI,OAAO;GACd,IAAI,cAAc;AAClB,OAAI,uBAAuB,cAAc;IACvC,IAAI,yBAAyB,gCAAgC,oBAAoB,yBAAyB;IAC1G,MAAM,EACJ,wBACA,wBACE;IACJ,IAAI,EACF,OACA,SACE;AACJ,QAAI;AACF,SAAI,0BAA0B,CAAC,WAAW,sBAAsB,mBAAmB,CACjF,SAAQ,MAAM,gBAAgB,wBAAwB,OAAO,0BAA0B,KAAK;AAE9F,SAAI,cAAc,CAAC,WAAW,sBAAsB,OAAO,CACzD,QAAO,MAAM,gBAAgB,YAAY,MAAM,cAAc,KAAK;KAEpE,IAAI,2BAA2B,MAAM,uBAAuB,OAAO,MAAM,IAAI,aAAa;AAC1F,SAAI,uBAAuB,CAAC,WAAW,sBAAsB,gBAAgB,CAC3E,4BAA2B,MAAM,gBAAgB,qBAAqB,0BAA0B,uBAAuB,KAAK;AAE9H,YAAO,gBAAgB,0BAA0B,mBAAmB,EAClE,eAAe,MAChB,CAAC,CAAC;aACI,GAAG;AACV,mBAAc;;;AAGlB,OAAI;AACF,QAAI,uBAAuB,kBAAkB;KAC3C,MAAM,OAAO;MACX,UAAU,IAAI;MACd,KAAK,IAAI;MACT,MAAM,IAAI;MACV,eAAe,IAAI,SAAS,UAAU,IAAI,gBAAgB,KAAK;MAChE;AACD,wBAAmB,kBAAkB,aAAa,KAAK;AACvD,uBAAkB,aAAa,KAAK;KACpC,MAAM,EACJ,qBAAqB,6BACnB;AACJ,SAAI,mBACF,QAAO,gBAAgB,mBAAmB,aAAa,KAAK,EAAE,mBAAmB,EAC/E,eAAe,YAAY,SAC5B,CAAC,CAAC;;YAGA,GAAG;AACV,kBAAc;;AAEhB,OAAI,OAAO,YAAY,eAAe,KACpC,SAAQ,MAAM,sEAAsE,IAAI,aAAa;kFAC3B,YAAY;OAEtF,SAAQ,MAAM,YAAY;AAE5B,SAAM;;;CAGV,SAAS,cAAc,KAAK,OAAO;EACjC,MAAM,eAAe,UAAU,iBAAiB,OAAO,IAAI,cAAc;EACzE,MAAM,8BAA8B,UAAU,aAAa,MAAM,CAAC;EAClE,MAAM,eAAe,cAAc;EACnC,MAAM,aAAa,IAAI,iBAAiB,IAAI,aAAa;AACzD,MAAI,WACF,QAAO,eAAe,SAAS,uBAAuB,IAAI,MAAM,CAAC,GAAG,OAAO,aAAa,IAAI,OAAO;AAErG,SAAO;;CAET,MAAM,yBAAyB;AA+C7B,SA9C4B,iBAAiB,GAAG,YAAY,gBAAgB,iBAAiB;GAC3F,eAAe,EACb,OACC;IACD,MAAM,qBAAqB,oBAAoB,IAAI;AACnD,WAAO,mBAAmB;KACxB,kBAAkB,KAAK,KAAK;KAC5B,GAAG,0BAA0B,mBAAmB,GAAG,EACjD,WAAW,IAAI,WAChB,GAAG,EAAE;KACP,CAAC;;GAEJ,UAAU,eAAe,EACvB,YACC;IACD,MAAM,QAAQ,UAAU;IACxB,MAAM,eAAe,UAAU,iBAAiB,OAAO,cAAc,cAAc;IACnF,MAAM,eAAe,cAAc;IACnC,MAAM,aAAa,cAAc;IACjC,MAAM,cAAc,cAAc;IAClC,MAAM,qBAAqB,oBAAoB,cAAc;IAC7D,MAAM,YAAY,cAAc;AAChC,QAAI,cAAc,cAAc,CAC9B,QAAO;AAET,QAAI,cAAc,WAAW,UAC3B,QAAO;AAET,QAAI,cAAc,eAAe,MAAM,CACrC,QAAO;AAET,QAAI,kBAAkB,mBAAmB,IAAI,oBAAoB,eAAe;KAC9E;KACA;KACA,eAAe;KACf;KACD,CAAC,CACA,QAAO;AAET,QAAI,gBAAgB,CAAC,UACnB,QAAO;AAET,WAAO;;GAET,4BAA4B;GAC7B,CAAC;;CAGJ,MAAM,aAAa,kBAAkB;CACrC,MAAM,qBAAqB,kBAAkB;CAC7C,MAAM,gBAAgB,iBAAiB,GAAG,YAAY,mBAAmB,iBAAiB,EACxF,iBAAiB;AACf,SAAO,mBAAmB,EACxB,kBAAkB,KAAK,KAAK,EAC7B,CAAC;IAEL,CAAC;CACF,MAAM,eAAe,YAAY,WAAW;CAC5C,MAAM,aAAa,YAAY,iBAAiB;CAChD,MAAM,YAAY,cAAc,KAAK,UAAU,EAAE,MAAM,UAAU,aAAa;EAC5E,MAAM,QAAQ,YAAY,QAAQ,IAAI,QAAQ;EAC9C,MAAM,SAAS,UAAU,QAAQ,IAAI,QAAQ;EAC7C,MAAM,eAAe,SAAS,SAAS;GACrC,MAAM,WAAW;IACf,cAAc;IACd,WAAW;IACZ;AACD,UAAO,IAAI,UAAU,cAAc,SAAS,KAAK,SAAS;;EAE5D,MAAM,mBAAmB,IAAI,UAAU,cAAc,OAAO,IAAI,CAAC,UAAU,CAAC;AAC5E,MAAI,MACF,UAAS,aAAa,CAAC;WACd,QAAQ;GACjB,MAAM,kBAAkB,kBAAkB;AAC1C,OAAI,CAAC,iBAAiB;AACpB,aAAS,aAAa,CAAC;AACvB;;AAGF,QADyB,uBAAuB,IAAI,MAAM,CAAC,GAAG,OAAO,IAAI,KAAK,gBAAgB,CAAC,IAAI,OAAO,OAExG,UAAS,aAAa,CAAC;QAGzB,UAAS,YAAY,MAAM,CAAC;;CAGhC,SAAS,gBAAgB,cAAc;AACrC,UAAQ,WAAW,QAAQ,MAAM,KAAK,iBAAiB;;CAEzD,SAAS,uBAAuB,OAAO,cAAc;AACnD,SAAO;GACL,cAAc,QAAQ,UAAU,MAAM,EAAE,gBAAgB,aAAa,CAAC;GACtE,gBAAgB,QAAQ,YAAY,MAAM,EAAE,gBAAgB,aAAa,CAAC;GAC1E,eAAe,QAAQ,WAAW,MAAM,EAAE,gBAAgB,aAAa,CAAC;GACzE;;AAEH,QAAO;EACL;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACD;;AAEH,SAAS,iBAAiB,SAAS,EACjC,OACA,cACC,UAAU;CACX,MAAM,YAAY,MAAM,SAAS;AACjC,QAAO,QAAQ,iBAAiB,MAAM,YAAY,OAAO,WAAW,YAAY,YAAY,SAAS;;AAEvG,SAAS,qBAAqB,SAAS,EACrC,OACA,cACC,UAAU;AACX,QAAO,QAAQ,uBAAuB,MAAM,IAAI,OAAO,WAAW,IAAI,YAAY,SAAS;;AAE7F,SAAS,yBAAyB,QAAQ,MAAM,qBAAqB,eAAe;AAClF,QAAO,oBAAoB,oBAAoB,OAAO,KAAK,IAAI,cAAc,OAAO,YAAY,OAAO,GAAG,OAAO,UAAU,KAAK,GAAG,oBAAoB,OAAO,GAAG,OAAO,UAAU,KAAK,GAAG,OAAO,KAAK,IAAI,cAAc,mBAAmB,OAAO,OAAO,OAAO,KAAK,gBAAgB,KAAK,GAAG,cAAc;;AAM7S,SAAS,4BAA4B,OAAO,eAAe,QAAQ;CACjE,MAAM,WAAW,MAAM;AACvB,KAAI,SACF,QAAO,SAAS;;AAGpB,SAAS,oBAAoB,IAAI;AAC/B,SAAQ,SAAS,KAAK,GAAG,IAAI,gBAAgB,GAAG,kBAAkB,GAAG;;AAEvE,SAAS,+BAA+B,OAAO,IAAI,QAAQ;CACzD,MAAM,WAAW,MAAM,oBAAoB,GAAG;AAC9C,KAAI,SACF,QAAO,SAAS;;AAGpB,IAAI,eAAe,EAAE;AACrB,SAAS,WAAW,EAClB,aACA,YACA,eACA,oBACA,SAAS,EACP,qBAAqB,aACrB,QACA,wBACA,sBAEF,eACA,UACC;CACD,MAAM,gBAAgB,aAAa,GAAG,YAAY,gBAAgB;CAClE,SAAS,uBAAuB,OAAO,KAAK,WAAW,MAAM;AAC3D,QAAM,IAAI,mBAAmB;GAC3B,QAAQ;GACR,cAAc,IAAI;GACnB;AACD,8BAA4B,OAAO,IAAI,gBAAgB,aAAa;AAClE,YAAS,SAAS;AAClB,YAAS,YAAY,aAAa,SAAS,YAEzC,SAAS,YAGT,KAAK;AAEP,OAAI,IAAI,iBAAiB,KAAK,EAC5B,UAAS,eAAe,IAAI;AAE9B,YAAS,mBAAmB,KAAK;GACjC,MAAM,qBAAqB,YAAY,KAAK,IAAI;AAChD,OAAI,0BAA0B,mBAAmB,IAAI,eAAe,IAElE,UAAS,YAAY,IAAI;IAE3B;;CAEJ,SAAS,yBAAyB,OAAO,MAAM,SAAS,WAAW;AACjE,8BAA4B,OAAO,KAAK,IAAI,gBAAgB,aAAa;AACvE,OAAI,SAAS,cAAc,KAAK,aAAa,CAAC,UAAW;GACzD,MAAM,EACJ,UACE,YAAY,KAAK,IAAI;AACzB,YAAS,SAAS;AAClB,OAAI,MACF,KAAI,SAAS,SAAS,KAAK,GAAG;IAC5B,MAAM,EACJ,oBACA,KACA,eACA,cACE;AASJ,aAAS,OARKA,QAAgB,SAAS,OAAO,sBAAsB;AAClE,YAAO,MAAM,mBAAmB,SAAS;MACvC,KAAK,IAAI;MACT;MACA;MACA;MACD,CAAC;MACF;SAGF,UAAS,OAAO;OAGlB,UAAS,OAAO,YAAY,KAAK,IAAI,cAAc,qBAAqB,OAAO,0BAA0B,QAAQ,SAAS,KAAK,GAAG,SAAS,SAAS,KAAK,GAAG,SAAS,MAAM,QAAQ,GAAG;AAExL,UAAO,SAAS;AAChB,YAAS,qBAAqB,KAAK;IACnC;;CAEJ,MAAM,aAAa,YAAY;EAC7B,MAAM,GAAG,YAAY;EACrB;EACA,UAAU;GACR,mBAAmB;IACjB,QAAQ,OAAO,EACb,SAAS,EACP,mBAED;AACD,YAAO,MAAM;;IAEf,SAAS,oBAAoB;IAC9B;GACD,sBAAsB;IACpB,QAAQ,OAAO,QAAQ;AACrB,UAAK,MAAM,SAAS,OAAO,SAAS;MAClC,MAAM,EACJ,kBAAkB,KAClB,UACE;AACJ,6BAAuB,OAAO,KAAK,MAAM;OACvC;OACA,WAAW,OAAO,KAAK;OACvB,kBAAkB,OAAO,KAAK;OAC/B,CAAC;AACF,+BACE,OACA;OACE;OACA,WAAW,OAAO,KAAK;OACvB,oBAAoB,OAAO,KAAK;OAChC,eAAe,EAAE;OAClB,EACD,OAEA,KACD;;;IAGL,UAAU,YAAY;AA+BpB,YARe;MACb,SAvBwB,QAAQ,KAAK,UAAU;OAC/C,MAAM,EACJ,cACA,KACA,UACE;OACJ,MAAM,qBAAqB,YAAY;AAWvC,cAAO;QACL,kBAXuB;SACvB,MAAM;SACN;SACA,cAAc,MAAM;SACpB,eAAe,mBAAmB;UAChC,WAAW;UACX;UACA;UACD,CAAC;SACH;QAGC;QACD;QACD;MAGA,MAAM;QACH,mBAAmB;OACpB,WAAW,QAAQ;OACnB,WAAW,KAAK,KAAK;OACtB;MACF;;IAGJ;GACD,oBAAoB;IAClB,QAAQ,OAAO,EACb,SAAS,EACP,eACA,aAED;AACD,iCAA4B,OAAO,gBAAgB,aAAa;AAC9D,eAAS,OAAO,aAAa,SAAS,MAAM,QAAQ,QAAQ,CAAC;OAC7D;;IAEJ,SAAS,oBAAoB;IAC9B;GACF;EACD,cAAc,SAAS;AACrB,WAAQ,QAAQ,WAAW,UAAU,OAAO,EAC1C,MACA,MAAM,EACJ,YAEE;IACJ,MAAM,YAAY,cAAc,IAAI;AACpC,2BAAuB,OAAO,KAAK,WAAW,KAAK;KACnD,CAAC,QAAQ,WAAW,YAAY,OAAO,EACvC,MACA,cACI;IACJ,MAAM,YAAY,cAAc,KAAK,IAAI;AACzC,6BAAyB,OAAO,MAAM,SAAS,UAAU;KACzD,CAAC,QAAQ,WAAW,WAAW,OAAO,EACtC,MAAM,EACJ,WACA,KACA,aAEF,OACA,cACI;AACJ,gCAA4B,OAAO,IAAI,gBAAgB,aAAa;AAClE,SAAI,WAAW,QACR;AACL,UAAI,SAAS,cAAc,UAAW;AACtC,eAAS,SAAS;AAClB,eAAS,QAAQ,WAAW;;MAE9B;KACF,CAAC,WAAW,qBAAqB,OAAO,WAAW;IACnD,MAAM,EACJ,YACE,uBAAuB,OAAO;AAClC,SAAK,MAAM,CAAC,KAAK,UAAU,OAAO,QAAQ,QAAQ,CAChD,KAEE,OAAO,WAAW,eAA+B,OAAO,WAAW,WAEnE,OAAM,OAAO;KAGjB;;EAEL,CAAC;CACF,MAAM,gBAAgB,YAAY;EAChC,MAAM,GAAG,YAAY;EACrB;EACA,UAAU,EACR,sBAAsB;GACpB,QAAQ,OAAO,EACb,WACC;IACD,MAAM,WAAW,oBAAoB,QAAQ;AAC7C,QAAI,YAAY,MACd,QAAO,MAAM;;GAGjB,SAAS,oBAAoB;GAC9B,EACF;EACD,cAAc,SAAS;AACrB,WAAQ,QAAQ,cAAc,UAAU,OAAO,EAC7C,MACA,MAAM,EACJ,WACA,KACA,yBAEE;AACJ,QAAI,CAAC,IAAI,MAAO;AAChB,UAAM,oBAAoB,KAAK,IAAI;KACjC;KACA,QAAQ;KACR,cAAc,IAAI;KAClB;KACD;KACD,CAAC,QAAQ,cAAc,YAAY,OAAO,EAC1C,SACA,WACI;AACJ,QAAI,CAAC,KAAK,IAAI,MAAO;AACrB,mCAA+B,OAAO,OAAO,aAAa;AACxD,SAAI,SAAS,cAAc,KAAK,UAAW;AAC3C,cAAS,SAAS;AAClB,cAAS,OAAO;AAChB,cAAS,qBAAqB,KAAK;MACnC;KACF,CAAC,QAAQ,cAAc,WAAW,OAAO,EACzC,SACA,OACA,WACI;AACJ,QAAI,CAAC,KAAK,IAAI,MAAO;AACrB,mCAA+B,OAAO,OAAO,aAAa;AACxD,SAAI,SAAS,cAAc,KAAK,UAAW;AAC3C,cAAS,SAAS;AAClB,cAAS,QAAQ,WAAW;MAC5B;KACF,CAAC,WAAW,qBAAqB,OAAO,WAAW;IACnD,MAAM,EACJ,cACE,uBAAuB,OAAO;AAClC,SAAK,MAAM,CAAC,KAAK,UAAU,OAAO,QAAQ,UAAU,CAClD,MAEG,OAAO,WAAW,eAA+B,OAAO,WAAW,eACpE,QAAQ,OAAO,UAEf,OAAM,OAAO;KAGjB;;EAEL,CAAC;CAKF,MAAM,oBAAoB,YAAY;EACpC,MAAM,GAAG,YAAY;EACrB,cAN+B;GAC/B,MAAM,EAAE;GACR,MAAM,EAAE;GACT;EAIC,UAAU,EACR,kBAAkB;GAChB,QAAQ,OAAO,QAAQ;AACrB,SAAK,MAAM,EACT,eACA,kBACG,OAAO,SAAS;AACnB,4BAAuB,OAAO,cAAc;AAC5C,UAAK,MAAM,EACT,MACA,QACG,cAAc;MACjB,MAAM,oBAAoB,CAAC,MAAM,KAAK,UAAU,EAAE,EAAE,MAAM,6BAA6B,EAAE;AAEzF,UAAI,CADsB,kBAAkB,SAAS,cAAc,CAEjE,mBAAkB,KAAK,cAAc;;AAGzC,WAAM,KAAK,iBAAiB;;;GAGhC,SAAS,oBAAoB;GAC9B,EACF;EACD,cAAc,SAAS;AACrB,WAAQ,QAAQ,WAAW,QAAQ,oBAAoB,OAAO,EAC5D,SAAS,EACP,sBAEE;AACJ,2BAAuB,OAAO,cAAc;KAC5C,CAAC,WAAW,qBAAqB,OAAO,WAAW;IACnD,MAAM,EACJ,aACE,uBAAuB,OAAO;AAClC,SAAK,MAAM,CAAC,MAAM,iBAAiB,OAAO,QAAQ,SAAS,QAAQ,EAAE,CAAC,CACpE,MAAK,MAAM,CAAC,IAAI,cAAc,OAAO,QAAQ,aAAa,EAAE;KAC1D,MAAM,oBAAoB,CAAC,MAAM,KAAK,UAAU,EAAE,EAAE,MAAM,6BAA6B,EAAE;AACzF,UAAK,MAAM,iBAAiB,WAAW;AAErC,UAAI,CADsB,kBAAkB,SAAS,cAAc,CAEjE,mBAAkB,KAAK,cAAc;AAEvC,YAAM,KAAK,iBAAiB,SAAS,KAAK;;;KAIhD,CAAC,WAAW,QAAQ,YAAY,WAAW,EAAE,oBAAoB,WAAW,CAAC,GAAG,OAAO,WAAW;AAClG,gCAA4B,OAAO,CAAC,OAAO,CAAC;KAC5C,CAAC,WAAW,WAAW,QAAQ,qBAAqB,QAAQ,OAAO,WAAW;IAC9E,MAAM,cAAc,OAAO,QAAQ,KAAK,EACtC,kBACA,YACI;AACJ,YAAO;MACL,MAAM;MACN,SAAS;MACT,MAAM;OACJ,eAAe;OACf,WAAW;OACX,KAAK;OACN;MACF;MACD;AACF,gCAA4B,OAAO,YAAY;KAC/C;;EAEL,CAAC;CACF,SAAS,uBAAuB,OAAO,eAAe;EACpD,MAAM,eAAe,MAAM,KAAK,kBAAkB,EAAE;AACpD,OAAK,MAAM,OAAO,cAAc;GAC9B,MAAM,UAAU,IAAI;GACpB,MAAM,QAAQ,IAAI,MAAM;GACxB,MAAM,mBAAmB,MAAM,KAAK,WAAW;AAC/C,OAAI,iBACF,OAAM,KAAK,SAAS,SAAS,iBAAiB,QAAQ,OAAO,OAAO,cAAc;;AAGtF,SAAO,MAAM,KAAK;;CAEpB,SAAS,4BAA4B,OAAO,UAAU;EACpD,MAAM,oBAAoB,SAAS,KAAK,WAAW;GACjD,MAAM,eAAe,yBAAyB,QAAQ,gBAAgB,aAAa,cAAc;GACjG,MAAM,EACJ,kBACE,OAAO,KAAK;AAChB,UAAO;IACL;IACA;IACD;IACD;AACF,oBAAkB,aAAa,iBAAiB,OAAO,kBAAkB,QAAQ,iBAAiB,kBAAkB,CAAC;;CAEvH,MAAM,oBAAoB,YAAY;EACpC,MAAM,GAAG,YAAY;EACrB;EACA,UAAU;GACR,0BAA0B,GAAG,GAAG;GAEhC,uBAAuB,GAAG,GAAG;GAE7B,gCAAgC;GAEjC;EACF,CAAC;CACF,MAAM,6BAA6B,YAAY;EAC7C,MAAM,GAAG,YAAY;EACrB;EACA,UAAU,EACR,sBAAsB;GACpB,QAAQ,OAAO,QAAQ;AACrB,WAAO,aAAa,OAAO,OAAO,QAAQ;;GAE5C,SAAS,oBAAoB;GAC9B,EACF;EACF,CAAC;CACF,MAAM,cAAc,YAAY;EAC9B,MAAM,GAAG,YAAY;EACrB,cAAc;GACZ,QAAQ,UAAU;GAClB,SAAS,mBAAmB;GAC5B,sBAAsB;GACtB,GAAG;GACJ;EACD,UAAU,EACR,qBAAqB,OAAO,EAC1B,WACC;AACD,SAAM,uBAAuB,MAAM,yBAAyB,cAAc,WAAW,UAAU,aAAa;KAE/G;EACD,gBAAgB,YAAY;AAC1B,WAAQ,QAAQ,WAAW,UAAU;AACnC,UAAM,SAAS;KACf,CAAC,QAAQ,YAAY,UAAU;AAC/B,UAAM,SAAS;KACf,CAAC,QAAQ,UAAU,UAAU;AAC7B,UAAM,UAAU;KAChB,CAAC,QAAQ,cAAc,UAAU;AACjC,UAAM,UAAU;KAChB,CAAC,WAAW,qBAAqB,WAAW,EAC5C,GAAG,OACJ,EAAE;;EAEN,CAAC;CACF,MAAM,kBAAkB,gBAAgB;EACtC,SAAS,WAAW;EACpB,WAAW,cAAc;EACzB,UAAU,kBAAkB;EAC5B,eAAe,2BAA2B;EAC1C,QAAQ,YAAY;EACrB,CAAC;CACF,MAAM,WAAW,OAAO,WAAW,gBAAgB,cAAc,MAAM,OAAO,GAAG,KAAK,IAAI,OAAO,OAAO;CACxG,MAAM,UAAU;EACd,GAAG,YAAY;EACf,GAAG,WAAW;EACd,GAAG,kBAAkB;EACrB,GAAG,2BAA2B;EAC9B,GAAG,cAAc;EACjB,GAAG,kBAAkB;EACrB;EACD;AACD,QAAO;EACL;EACA;EACD;;AAIH,IAAI,YAA4B,uBAAO,IAAI,iBAAiB;AAC5D,IAAI,kBAAkB,EACpB,QAAQ,iBACT;AACD,IAAI,uBAAuC,wBAAgB,uBAAuB,GAChF;AACF,IAAI,0BAA0C,wBAAgB,uBAAuB,GACnF;AACF,SAAS,eAAe,EACtB,oBACA,aACA,gBAAgB,mBACf;CACD,MAAM,sBAAsB,UAAU;CACtC,MAAM,yBAAyB,UAAU;AACzC,QAAO;EACL;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACD;CACD,SAAS,iBAAiB,UAAU;AAClC,SAAO;GACL,GAAG;GACH,GAAG,sBAAsB,SAAS,OAAO;GAC1C;;CAEH,SAAS,eAAe,WAAW;EACjC,MAAM,QAAQ,UAAU;AAEtB,MAAI,CAAC,OAAO;AACV,OAAI,eAAe,UAAW,QAAO;AACrC,kBAAe,YAAY;AAC3B,WAAQ,MAAM,mCAAmC,YAAY,qDAAqD;;AAGtH,SAAO;;CAET,SAAS,cAAc,WAAW;AAChC,SAAO,eAAe,UAAU,EAAE;;CAEpC,SAAS,iBAAiB,WAAW,UAAU;AAC7C,SAAO,cAAc,UAAU,GAAG;;CAEpC,SAAS,gBAAgB,WAAW;AAClC,SAAO,eAAe,UAAU,EAAE;;CAEpC,SAAS,aAAa,WAAW;AAC/B,SAAO,eAAe,UAAU,EAAE;;CAEpC,SAAS,sBAAsB,cAAc,oBAAoB,UAAU;AACzE,UAAQ,cAAc;AACpB,OAAI,cAAc,UAChB,QAAO,gBAAgB,oBAAoB,SAAS;GAEtD,MAAM,iBAAiB,mBAAmB;IACxC;IACA;IACA;IACD,CAAC;GACF,MAAM,uBAAuB,UAAU,iBAAiB,OAAO,eAAe,IAAI;AAClF,UAAO,gBAAgB,qBAAqB,SAAS;;;CAGzD,SAAS,mBAAmB,cAAc,oBAAoB;AAC5D,SAAO,sBAAsB,cAAc,oBAAoB,iBAAiB;;CAElF,SAAS,2BAA2B,cAAc,oBAAoB;EACpE,MAAM,EACJ,yBACE;EACJ,SAAS,6BAA6B,UAAU;GAC9C,MAAM,wBAAwB;IAC5B,GAAG;IACH,GAAG,sBAAsB,SAAS,OAAO;IAC1C;GACD,MAAM,EACJ,WACA,SACA,cACE;GACJ,MAAM,YAAY,cAAc;GAChC,MAAM,aAAa,cAAc;AACjC,UAAO;IACL,GAAG;IACH,aAAa,eAAe,sBAAsB,sBAAsB,MAAM,sBAAsB,aAAa;IACjH,iBAAiB,mBAAmB,sBAAsB,sBAAsB,MAAM,sBAAsB,aAAa;IACzH,oBAAoB,aAAa;IACjC,wBAAwB,aAAa;IACrC,sBAAsB,WAAW;IACjC,0BAA0B,WAAW;IACtC;;AAEH,SAAO,sBAAsB,cAAc,oBAAoB,6BAA6B;;CAE9F,SAAS,wBAAwB;AAC/B,UAAQ,OAAO;GACb,IAAI;AACJ,OAAI,OAAO,OAAO,SAChB,cAAa,oBAAoB,GAAG,IAAI;OAExC,cAAa;GAEf,MAAM,0BAA0B,UAAU,eAAe,MAAM,EAAE,YAAY,eAAe;AAE5F,UAAO,gBAD6B,eAAe,YAAY,wBAAwB,wBACnC,iBAAiB;;;CAGzE,SAAS,oBAAoB,OAAO,MAAM;EACxC,MAAM,WAAW,MAAM;EACvB,MAAM,+BAA+B,IAAI,KAAK;AAC9C,OAAK,MAAM,OAAO,KAAK,OAAO,aAAa,CAAC,IAAI,qBAAqB,EAAE;GACrE,MAAM,WAAW,SAAS,SAAS,KAAK,IAAI;AAC5C,OAAI,CAAC,SACH;GAEF,IAAI,2BAA2B,IAAI,OAAO,KAAK,IAE7C,SAAS,IAAI,MAGb,QAAQ,OAAO,OAAO,SAAS,CAAC,KAC5B,EAAE;AACR,QAAK,MAAM,cAAc,wBACvB,cAAa,IAAI,WAAW;;AAGhC,SAAO,QAAQ,MAAM,KAAK,aAAa,QAAQ,CAAC,CAAC,KAAK,kBAAkB;GACtE,MAAM,gBAAgB,SAAS,QAAQ;AACvC,UAAO,gBAAgB,CAAC;IACtB;IACA,cAAc,cAAc;IAC5B,cAAc,cAAc;IAC7B,CAAC,GAAG,EAAE;IACP,CAAC;;CAEL,SAAS,yBAAyB,OAAO,WAAW;AAClD,SAAO,OAAO,OAAO,cAAc,MAAM,CAAC,CAAC,QAAQ,UAAU,OAAO,iBAAiB,aAAa,MAAM,WAAW,gBAAoC,CAAC,KAAK,UAAU,MAAM,aAAa;;CAE5L,SAAS,eAAe,SAAS,MAAM,UAAU;AAC/C,MAAI,CAAC,KAAM,QAAO;AAClB,SAAO,iBAAiB,SAAS,MAAM,SAAS,IAAI;;CAEtD,SAAS,mBAAmB,SAAS,MAAM,UAAU;AACnD,MAAI,CAAC,QAAQ,CAAC,QAAQ,qBAAsB,QAAO;AACnD,SAAO,qBAAqB,SAAS,MAAM,SAAS,IAAI;;;AAQ5D,IAAI,QAAQ,0BAA0B,IAAI,SAAS,GAAG,KAAK;AAC3D,IAAI,6BAA6B,EAC/B,cACA,gBACI;CACJ,IAAI,aAAa;CACjB,MAAM,SAAS,OAAO,IAAI,UAAU;AACpC,KAAI,OAAO,WAAW,SACpB,cAAa;MACR;EACL,MAAM,cAAc,KAAK,UAAU,YAAY,KAAK,UAAU;AAC5D,WAAQ,OAAO,UAAU,WAAW,EAClC,SAAS,MAAM,UAAU,EAC1B,GAAG;AACJ,WAAQ,cAAc,MAAM,GAAG,OAAO,KAAK,MAAM,CAAC,MAAM,CAAC,QAAQ,KAAK,SAAS;AAC7E,QAAI,QAAQ,MAAM;AAClB,WAAO;MACN,EAAE,CAAC,GAAG;AACT,UAAO;IACP;AACF,MAAI,cAAc,UAAU,CAC1B,QAAO,IAAI,WAAW,YAAY;AAEpC,eAAa;;AAEf,QAAO,GAAG,aAAa,GAAG,WAAW;;AAKvC,SAAS,eAAe,GAAG,SAAS;AAClC,QAAO,SAAS,cAAc,SAAS;EACrC,MAAM,yBAAyB,gBAAgB,WAAW,QAAQ,yBAAyB,QAAQ,EACjG,aAAa,QAAQ,eAAe,OACrC,CAAC,CAAC;EACH,MAAM,sBAAsB;GAC1B,aAAa;GACb,mBAAmB;GACnB,2BAA2B;GAC3B,gBAAgB;GAChB,oBAAoB;GACpB,sBAAsB;GACtB,GAAG;GACH;GACA,mBAAmB,cAAc;IAC/B,IAAI,0BAA0B;AAC9B,QAAI,wBAAwB,aAAa,oBAAoB;KAC3D,MAAM,cAAc,aAAa,mBAAmB;AACpD,gCAA2B,kBAAkB;MAC3C,MAAM,gBAAgB,YAAY,cAAc;AAChD,UAAI,OAAO,kBAAkB,SAC3B,QAAO;UAEP,QAAO,0BAA0B;OAC/B,GAAG;OACH,WAAW;OACZ,CAAC;;eAGG,QAAQ,mBACjB,2BAA0B,QAAQ;AAEpC,WAAO,wBAAwB,aAAa;;GAE9C,UAAU,CAAC,GAAG,QAAQ,YAAY,EAAE,CAAC;GACtC;EACD,MAAM,UAAU;GACd,qBAAqB,EAAE;GACvB,MAAM,IAAI;AACR,QAAI;;GAEN,QAAQ,QAAQ;GAChB;GACA,oBAAoB,gBAAgB,WAAW,uBAAuB,OAAO,IAAI,KAAK;GACvF;EACD,MAAM,MAAM;GACV;GACA,iBAAiB,EACf,aACA,aACC;AACD,QAAI,aACF;UAAK,MAAM,MAAM,YACf,KAAI,CAAC,oBAAoB,SAAS,SAAS,GAAG,CAE5C,qBAAoB,SAAS,KAAK,GAAG;;AAI3C,QAAI,UACF,MAAK,MAAM,CAAC,cAAc,sBAAsB,OAAO,QAAQ,UAAU,CACvE,KAAI,OAAO,sBAAsB,WAC/B,mBAAkB,QAAQ,oBAAoB,cAAc;QAE5D,QAAO,OAAO,QAAQ,oBAAoB,iBAAiB,EAAE,EAAE,kBAAkB;AAIvF,WAAO;;GAEV;EACD,MAAM,qBAAqB,QAAQ,KAAK,MAAM,EAAE,KAAK,KAAK,qBAAqB,QAAQ,CAAC;EACxF,SAAS,gBAAgB,QAAQ;GAC/B,MAAM,qBAAqB,OAAO,UAAU;IAC1C,QAAQ,OAAO;KACb,GAAG;KACH,MAAM;KACP;IACD,WAAW,OAAO;KAChB,GAAG;KACH,MAAM;KACP;IACD,gBAAgB,OAAO;KACrB,GAAG;KACH,MAAM;KACP;IACF,CAAC;AACF,QAAK,MAAM,CAAC,cAAc,eAAe,OAAO,QAAQ,mBAAmB,EAAE;AAC3E,QAAI,OAAO,qBAAqB,QAAQ,gBAAgB,QAAQ,qBAAqB;AACnF,SAAI,OAAO,qBAAqB,QAC9B,OAAM,IAAI,MAA6E,wEAAwE,aAAa,gDAAgD;cACnN,OAAO,YAAY,eAAe,KAC3C,SAAQ,MAAM,wEAAwE,aAAa,gDAAgD;AAErJ;;AAEF,QAAI,OAAO,YAAY,eAAe,MACpC;SAAI,0BAA0B,WAAW,EAAE;MACzC,MAAM,EACJ,yBACE;MACJ,MAAM,EACJ,UACA,sBAAsB,0BACpB;AACJ,UAAI,OAAO,aAAa,UAAU;AAChC,WAAI,WAAW,EACb,OAAM,IAAI,MAA8E,0BAA0B,aAAa,mCAAmC;AAEpK,WAAI,OAAO,0BAA0B,WACnC,OAAM,IAAI,MAA6E,sCAAsC,aAAa,0CAA0C;;;;AAK5L,YAAQ,oBAAoB,gBAAgB;AAC5C,SAAK,MAAM,KAAK,mBACd,GAAE,eAAe,cAAc,WAAW;;AAG9C,UAAO;;AAET,SAAO,IAAI,gBAAgB,EACzB,WAAW,QAAQ,WACpB,CAAC;;;AAMN,IAAI,SAAyB,wBAAQ;AACrC,SAAS,gBAAgB;AACvB,QAAO,WAAW;AAChB,QAAM,IAAI,MAA6E,gGAAgG;;;AAQ3L,SAAS,WAAW,GAAG;AAEvB,SAAS,WAAW,QAAQ,GAAG,MAAM;AACnC,QAAO,OAAO,OAAO,QAAQ,GAAG,KAAK;;AAKvC,IAAI,8BAA8B,EAChC,KACA,YACA,eACA,YACI;CACJ,MAAM,sBAAsB,GAAG,IAAI,YAAY;CAC/C,IAAI,wBAAwB;CAC5B,IAAI,kBAAkB;CACtB,MAAM,EACJ,2BACA,2BACE,IAAI;CACR,MAAM,+BAA+B,sBAAsB,WAAW;AACpE,MAAI,0BAA0B,MAAM,OAAO,EAAE;GAC3C,MAAM,EACJ,eACA,WACA,YACE,OAAO;GACX,MAAM,MAAM,qBAAqB,IAAI,cAAc;AACnD,OAAI,KAAK,IAAI,UAAU,CACrB,KAAI,IAAI,WAAW,QAAQ;AAE7B,UAAO;;AAET,MAAI,uBAAuB,MAAM,OAAO,EAAE;GACxC,MAAM,EACJ,eACA,cACE,OAAO;GACX,MAAM,MAAM,qBAAqB,IAAI,cAAc;AACnD,OAAI,IACF,KAAI,OAAO,UAAU;AAEvB,UAAO;;AAET,MAAI,IAAI,gBAAgB,kBAAkB,MAAM,OAAO,EAAE;AACvD,wBAAqB,OAAO,OAAO,QAAQ,cAAc;AACzD,UAAO;;AAET,MAAI,WAAW,QAAQ,MAAM,OAAO,EAAE;GACpC,MAAM,EACJ,MAAM,EACJ,KACA,gBAEA;GACJ,MAAM,WAAW,oBAAoB,sBAAsB,IAAI,eAAe,aAAa;AAC3F,OAAI,IAAI,UACN,UAAS,IAAI,WAAW,IAAI,uBAAuB,SAAS,IAAI,UAAU,IAAI,EAAE,CAAC;AAEnF,UAAO;;EAET,IAAI,UAAU;AACd,MAAI,WAAW,SAAS,MAAM,OAAO,EAAE;GACrC,MAAM,EACJ,MAAM,EACJ,WACA,KACA,gBAEA;AACJ,OAAI,aAAa,IAAI,WAAW;IAC9B,MAAM,WAAW,oBAAoB,sBAAsB,IAAI,eAAe,aAAa;AAC3F,aAAS,IAAI,WAAW,IAAI,uBAAuB,SAAS,IAAI,UAAU,IAAI,EAAE,CAAC;AACjF,cAAU;;;AAGd,SAAO;;CAET,MAAM,yBAAyB,cAAc;CAC7C,MAAM,wBAAwB,kBAAkB;AAG9C,SAFsB,kBAAkB,CACO,IAAI,cAAc,EAChC,QAAQ;;CAE3C,MAAM,uBAAuB,eAAe,cAAc;AAExD,SAAO,CAAC,CADc,kBAAkB,EAChB,IAAI,cAAc,EAAE,IAAI,UAAU;;CAE5D,MAAM,wBAAwB;EAC5B;EACA;EACA;EACD;CACD,SAAS,uBAAuB,sBAAsB;AACpD,SAAO,KAAK,MAAM,KAAK,UAAU,OAAO,YAAY,CAAC,GAAG,qBAAqB,CAAC,KAAK,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,YAAY,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;;AAE9H,SAAQ,QAAQ,WAAW;AACzB,MAAI,CAAC,sBACH,yBAAwB,uBAAuB,cAAc,qBAAqB;AAEpF,MAAI,IAAI,KAAK,cAAc,MAAM,OAAO,EAAE;AACxC,2BAAwB,EAAE;AAC1B,iBAAc,qBAAqB,OAAO;AAC1C,qBAAkB;AAClB,UAAO,CAAC,MAAM,MAAM;;AAEtB,MAAI,IAAI,gBAAgB,8BAA8B,MAAM,OAAO,CACjE,QAAO,CAAC,OAAO,sBAAsB;EAEvC,MAAM,YAAY,4BAA4B,cAAc,sBAAsB,OAAO;EACzF,IAAI,uBAAuB;AAI3B,MAAI,WAAW;AACb,OAAI,CAAC,gBACH,mBAAkB,iBAAiB;IACjC,MAAM,mBAAmB,uBAAuB,cAAc,qBAAqB;IACnF,MAAM,GAAG,WAAWC,mBAAoB,6BAA6B,iBAAiB;AACtF,WAAO,KAAK,IAAI,gBAAgB,qBAAqB,QAAQ,CAAC;AAC9D,4BAAwB;AACxB,sBAAkB;MACjB,IAAI;GAET,MAAM,4BAA4B,OAAO,OAAO,QAAQ,YAAY,CAAC,CAAC,OAAO,KAAK,WAAW,oBAAoB;GACjH,MAAM,iCAAiC,WAAW,SAAS,MAAM,OAAO,IAAI,OAAO,KAAK,aAAa,CAAC,CAAC,OAAO,KAAK,IAAI;AACvH,0BAAuB,CAAC,6BAA6B,CAAC;;AAExD,SAAO,CAAC,sBAAsB,MAAM;;;AAKxC,IAAI,mCAAmC,aAAa,MAAM;AAC1D,IAAI,+BAA+B,EACjC,aACA,KACA,YACA,SACA,eACA,WAAW,EACT,kBACA,gBAEF,sBACA,YACI;CACJ,MAAM,EACJ,mBACA,wBACA,yBACE,IAAI;CACR,MAAM,wBAAwB,QAAQ,uBAAuB,OAAO,WAAW,WAAW,WAAW,UAAU,qBAAqB,MAAM;CAC1I,SAAS,gCAAgC,eAAe;EACtD,MAAM,gBAAgB,cAAc,qBAAqB,IAAI,cAAc;AAC3E,MAAI,CAAC,cACH,QAAO;AAGT,SADyB,cAAc,OAAO;;CAGhD,MAAM,yBAAyB,EAAE;CACjC,SAAS,iBAAiB,YAAY;AACpC,OAAK,MAAM,WAAW,WAAW,QAAQ,CACvC,UAAS,SAAS;;CAGtB,MAAM,WAAW,QAAQ,WAAW;EAClC,MAAM,QAAQ,OAAO,UAAU;EAC/B,MAAM,SAAS,aAAa,MAAM;AAClC,MAAI,sBAAsB,OAAO,EAAE;GACjC,IAAI;AACJ,OAAI,qBAAqB,MAAM,OAAO,CACpC,kBAAiB,OAAO,QAAQ,KAAK,UAAU,MAAM,iBAAiB,cAAc;QAC/E;IACL,MAAM,EACJ,kBACE,uBAAuB,MAAM,OAAO,GAAG,OAAO,UAAU,OAAO,KAAK;AACxE,qBAAiB,CAAC,cAAc;;AAElC,yBAAsB,gBAAgB,QAAQ,OAAO;;AAEvD,MAAI,IAAI,KAAK,cAAc,MAAM,OAAO,EAAE;AACxC,QAAK,MAAM,CAAC,KAAK,YAAY,OAAO,QAAQ,uBAAuB,EAAE;AACnE,QAAI,QAAS,cAAa,QAAQ;AAClC,WAAO,uBAAuB;;AAEhC,oBAAiB,cAAc,eAAe;AAC9C,oBAAiB,cAAc,iBAAiB;;AAElD,MAAI,QAAQ,mBAAmB,OAAO,EAAE;GACtC,MAAM,EACJ,YACE,QAAQ,uBAAuB,OAAO;AAC1C,yBAAsB,OAAO,KAAK,QAAQ,EAAE,QAAQ,OAAO;;;CAG/D,SAAS,sBAAsB,WAAW,MAAM,QAAQ;EACtD,MAAM,QAAQ,KAAK,UAAU;AAC7B,OAAK,MAAM,iBAAiB,WAAW;GACrC,MAAM,QAAQ,iBAAiB,OAAO,cAAc;AACpD,OAAI,OAAO,aACT,mBAAkB,eAAe,MAAM,cAAc,MAAM,OAAO;;;CAIxE,SAAS,kBAAkB,eAAe,cAAc,MAAM,QAAQ;EAEpE,MAAM,oBADqB,QAAQ,oBAAoB,eACT,qBAAqB,OAAO;AAC1E,MAAI,sBAAsB,SACxB;EAEF,MAAM,yBAAyB,KAAK,IAAI,GAAG,KAAK,IAAI,mBAAmB,iCAAiC,CAAC;AACzG,MAAI,CAAC,gCAAgC,cAAc,EAAE;GACnD,MAAM,iBAAiB,uBAAuB;AAC9C,OAAI,eACF,cAAa,eAAe;AAE9B,0BAAuB,iBAAiB,iBAAiB;AACvD,QAAI,CAAC,gCAAgC,cAAc,EAAE;KACnD,MAAM,QAAQ,iBAAiB,KAAK,UAAU,EAAE,cAAc;AAC9D,SAAI,OAAO,aAET,CADqB,KAAK,SAAS,qBAAqB,MAAM,cAAc,MAAM,aAAa,CAAC,EAClF,OAAO;AAEvB,UAAK,SAAS,kBAAkB,EAC9B,eACD,CAAC,CAAC;;AAEL,WAAO,uBAAuB;MAC7B,yBAAyB,IAAI;;;AAGpC,QAAO;;AAIT,IAAI,qCAAqB,IAAI,MAAM,mDAAmD;AACtF,IAAI,8BAA8B,EAChC,KACA,aACA,SACA,YACA,eACA,eACA,WAAW,EACT,kBACA,uBAEE;CACJ,MAAM,eAAe,mBAAmB,WAAW;CACnD,MAAM,kBAAkB,mBAAmB,cAAc;CACzD,MAAM,mBAAmB,YAAY,YAAY,cAAc;CAC/D,MAAM,eAAe,EAAE;CACvB,SAAS,sBAAsB,UAAU,MAAM,MAAM;EACnD,MAAM,YAAY,aAAa;AAC/B,MAAI,WAAW,eAAe;AAC5B,aAAU,cAAc;IACtB;IACA;IACD,CAAC;AACF,UAAO,UAAU;;;CAGrB,SAAS,qBAAqB,UAAU;EACtC,MAAM,YAAY,aAAa;AAC/B,MAAI,WAAW;AACb,UAAO,aAAa;AACpB,aAAU,mBAAmB;;;CAGjC,MAAM,WAAW,QAAQ,OAAO,gBAAgB;EAC9C,MAAM,WAAW,YAAY,OAAO;EACpC,SAAS,oBAAoB,cAAc,WAAW,WAAW,cAAc;GAC7E,MAAM,WAAW,iBAAiB,aAAa,UAAU;GACzD,MAAM,WAAW,iBAAiB,MAAM,UAAU,EAAE,UAAU;AAC9D,OAAI,CAAC,YAAY,SACf,cAAa,cAAc,cAAc,WAAW,OAAO,UAAU;;AAGzE,MAAI,WAAW,QAAQ,MAAM,OAAO,CAClC,qBAAoB,OAAO,KAAK,IAAI,cAAc,UAAU,OAAO,KAAK,WAAW,OAAO,KAAK,IAAI,aAAa;WACvG,IAAI,gBAAgB,qBAAqB,MAAM,OAAO,CAC/D,MAAK,MAAM,EACT,kBACA,WACG,OAAO,SAAS;GACnB,MAAM,EACJ,cACA,cACA,kBACE;AACJ,uBAAoB,cAAc,eAAe,OAAO,KAAK,WAAW,aAAa;AACrF,yBAAsB,eAAe,OAAO,EAAE,CAAC;;WAExC,cAAc,QAAQ,MAAM,OAAO,EAE5C;OADc,MAAM,UAAU,CAAC,aAAa,UAAU,UAEpD,cAAa,OAAO,KAAK,IAAI,cAAc,OAAO,KAAK,IAAI,cAAc,UAAU,OAAO,OAAO,KAAK,UAAU;aAEzG,iBAAiB,OAAO,CACjC,uBAAsB,UAAU,OAAO,SAAS,OAAO,KAAK,cAAc;WACjE,IAAI,gBAAgB,kBAAkB,MAAM,OAAO,IAAI,IAAI,gBAAgB,qBAAqB,MAAM,OAAO,CACtH,sBAAqB,SAAS;WACrB,IAAI,KAAK,cAAc,MAAM,OAAO,CAC7C,MAAK,MAAM,aAAa,OAAO,KAAK,aAAa,CAC/C,sBAAqB,UAAU;;CAIrC,SAAS,YAAY,QAAQ;AAC3B,MAAI,aAAa,OAAO,CAAE,QAAO,OAAO,KAAK,IAAI;AACjD,MAAI,gBAAgB,OAAO,CACzB,QAAO,OAAO,KAAK,IAAI,iBAAiB,OAAO,KAAK;AAEtD,MAAI,IAAI,gBAAgB,kBAAkB,MAAM,OAAO,CAAE,QAAO,OAAO,QAAQ;AAC/E,MAAI,IAAI,gBAAgB,qBAAqB,MAAM,OAAO,CAAE,QAAO,oBAAoB,OAAO,QAAQ;AACtG,SAAO;;CAET,SAAS,aAAa,cAAc,cAAc,eAAe,OAAO,WAAW;EACjF,MAAM,qBAAqB,QAAQ,oBAAoB;EACvD,MAAM,oBAAoB,oBAAoB;AAC9C,MAAI,CAAC,kBAAmB;EACxB,MAAM,YAAY,EAAE;EACpB,MAAM,oBAAoB,IAAI,SAAS,YAAY;AACjD,aAAU,oBAAoB;IAC9B;EACF,MAAM,kBAAkB,QAAQ,KAAK,CAAC,IAAI,SAAS,YAAY;AAC7D,aAAU,gBAAgB;IAC1B,EAAE,kBAAkB,WAAW;AAC/B,SAAM;IACN,CAAC,CAAC;AACJ,kBAAgB,YAAY,GAC1B;AACF,eAAa,iBAAiB;EAC9B,MAAM,WAAW,IAAI,UAAU,cAAc,OAAO,qBAAqB,mBAAmB,GAAG,eAAe,cAAc;EAC5H,MAAM,QAAQ,MAAM,UAAU,GAAG,IAAI,WAAW,OAAO;EACvD,MAAM,eAAe;GACnB,GAAG;GACH,qBAAqB,SAAS,MAAM,UAAU,CAAC;GAC/C;GACA;GACA,kBAAkB,qBAAqB,mBAAmB,IAAI,iBAAiB,MAAM,SAAS,IAAI,KAAK,gBAAgB,cAAc,cAAc,aAAa,CAAC,GAAG,KAAK;GACzK;GACA;GACD;EACD,MAAM,iBAAiB,kBAAkB,cAAc,aAAa;AACpE,UAAQ,QAAQ,eAAe,CAAC,OAAO,MAAM;AAC3C,OAAI,MAAM,mBAAoB;AAC9B,SAAM;IACN;;AAEJ,QAAO;;AAIT,IAAI,wBAAwB,EAC1B,KACA,SAAS,EACP,UAEF,kBACI;AACJ,SAAQ,QAAQ,UAAU;AACxB,MAAI,IAAI,KAAK,cAAc,MAAM,OAAO,CACtC,OAAM,SAAS,IAAI,gBAAgB,qBAAqB,OAAO,CAAC;AAElE,MAAI,OAAO,YAAY,eAAe,MACpC;OAAI,IAAI,gBAAgB,qBAAqB,MAAM,OAAO,IAAI,OAAO,YAAY,UAAU,MAAM,UAAU,CAAC,cAAc,QAAQ,yBAAyB,WACzJ,SAAQ,KAAK,yEAAyE,YAAY;8FACZ,gBAAgB,QAAQ;iGACrB,KAAK;;;;AAOtG,IAAI,kCAAkC,EACpC,aACA,SACA,SAAS,EACP,uBAEF,eACA,YACA,KACA,eACA,cACA,oBACI;CACJ,MAAM,EACJ,sBACE,IAAI;CACR,MAAM,wBAAwB,QAAQ,YAAY,cAAc,EAAE,oBAAoB,cAAc,CAAC;CACrG,MAAM,aAAa,QAAQ,YAAY,eAAe,WAAW,EAAE,WAAW,eAAe,WAAW,CAAC;CACzG,IAAI,0BAA0B,EAAE;CAChC,MAAM,WAAW,QAAQ,UAAU;AACjC,MAAI,sBAAsB,OAAO,CAC/B,gBAAe,yBAAyB,QAAQ,mBAAmB,qBAAqB,cAAc,EAAE,MAAM;WACrG,WAAW,OAAO,CAC3B,gBAAe,EAAE,EAAE,MAAM;WAChB,IAAI,KAAK,eAAe,MAAM,OAAO,CAC9C,gBAAe,oBAAoB,OAAO,SAAS,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,cAAc,EAAE,MAAM;;CAG7G,SAAS,mBAAmB,OAAO;EACjC,MAAM,EACJ,SACA,cACE;AACJ,OAAK,MAAM,eAAe,CAAC,SAAS,UAAU,CAC5C,MAAK,MAAM,OAAO,YAChB,KAAI,YAAY,MAAM,WAAW,UAAyB,QAAO;AAGrE,SAAO;;CAET,SAAS,eAAe,SAAS,OAAO;EACtC,MAAM,YAAY,MAAM,UAAU;EAClC,MAAM,QAAQ,UAAU;AACxB,0BAAwB,KAAK,GAAG,QAAQ;AACxC,MAAI,MAAM,OAAO,yBAAyB,aAAa,mBAAmB,MAAM,CAC9E;EAEF,MAAM,OAAO;AACb,4BAA0B,EAAE;AAC5B,MAAI,KAAK,WAAW,EAAG;EACvB,MAAM,eAAe,IAAI,KAAK,oBAAoB,WAAW,KAAK;AAClE,UAAQ,YAAY;GAClB,MAAM,cAAc,MAAM,KAAK,aAAa,QAAQ,CAAC;AACrD,QAAK,MAAM,EACT,mBACG,aAAa;IAChB,MAAM,gBAAgB,MAAM,QAAQ;IACpC,MAAM,uBAAuB,oBAAoB,cAAc,sBAAsB,eAAe,aAAa;AACjH,QAAI,eACF;SAAI,qBAAqB,SAAS,EAChC,OAAM,SAAS,kBAAkB,EAC/B,eACD,CAAC,CAAC;cACM,cAAc,WAAW,gBAClC,OAAM,SAAS,aAAa,cAAc,CAAC;;;IAIjD;;AAEJ,QAAO;;AAIT,IAAI,uBAAuB,EACzB,aACA,YACA,KACA,cACA,oBACI;CACJ,MAAM,EACJ,cACA,yBACE;CACJ,MAAM,wCAAwC,IAAI,KAAK;CACvD,IAAI,qBAAqB;CACzB,MAAM,WAAW,QAAQ,UAAU;AACjC,MAAI,IAAI,gBAAgB,0BAA0B,MAAM,OAAO,IAAI,IAAI,gBAAgB,uBAAuB,MAAM,OAAO,CACzH,uBAAsB,OAAO,QAAQ,eAAe,MAAM;AAE5D,MAAI,WAAW,QAAQ,MAAM,OAAO,IAAI,WAAW,SAAS,MAAM,OAAO,IAAI,OAAO,KAAK,UACvF,uBAAsB,OAAO,KAAK,IAAI,eAAe,MAAM;AAE7D,MAAI,WAAW,UAAU,MAAM,OAAO,IAAI,WAAW,SAAS,MAAM,OAAO,IAAI,CAAC,OAAO,KAAK,UAC1F,eAAc,OAAO,KAAK,KAAK,MAAM;AAEvC,MAAI,IAAI,KAAK,cAAc,MAAM,OAAO,EAAE;AACxC,eAAY;AACZ,OAAI,oBAAoB;AACtB,iBAAa,mBAAmB;AAChC,yBAAqB;;AAEvB,yBAAsB,OAAO;;;CAGjC,SAAS,sBAAsB,eAAe,MAAM;AAClD,wBAAsB,IAAI,cAAc;AACxC,MAAI,CAAC,mBACH,sBAAqB,iBAAiB;AACpC,QAAK,MAAM,OAAO,sBAChB,uBAAsB,EACpB,eAAe,KAChB,EAAE,KAAK;AAEV,yBAAsB,OAAO;AAC7B,wBAAqB;KACpB,EAAE;;CAUT,SAAS,cAAc,EACrB,iBACC,MAAM;EACP,MAAM,QAAQ,KAAK,UAAU,CAAC;EAC9B,MAAM,gBAAgB,MAAM,QAAQ;EACpC,MAAM,gBAAgB,qBAAqB,IAAI,cAAc;AAC7D,MAAI,CAAC,iBAAiB,cAAc,WAAW,gBAAqC;EACpF,MAAM,EACJ,uBACA,2BACE,0BAA0B,cAAc;AAC5C,MAAI,CAAC,OAAO,SAAS,sBAAsB,CAAE;EAC7C,MAAM,cAAc,aAAa,IAAI,cAAc;AACnD,MAAI,aAAa,SAAS;AACxB,gBAAa,YAAY,QAAQ;AACjC,eAAY,UAAU,KAAK;;EAE7B,MAAM,oBAAoB,KAAK,KAAK,GAAG;AACvC,eAAa,IAAI,eAAe;GAC9B;GACA,iBAAiB;GACjB,SAAS,iBAAiB;AACxB,QAAI,MAAM,OAAO,WAAW,CAAC,uBAC3B,MAAK,SAAS,aAAa,cAAc,CAAC;AAE5C,kBAAc,EACZ,eACD,EAAE,KAAK;MACP,sBAAsB;GAC1B,CAAC;;CAEJ,SAAS,sBAAsB,EAC7B,iBACC,MAAM;EAEP,MAAM,gBADQ,KAAK,UAAU,CAAC,aACF,QAAQ;EACpC,MAAM,gBAAgB,qBAAqB,IAAI,cAAc;AAC7D,MAAI,CAAC,iBAAiB,cAAc,WAAW,gBAC7C;EAEF,MAAM,EACJ,0BACE,0BAA0B,cAAc;AAM5C,MAAI,CAAC,OAAO,SAAS,sBAAsB,EAAE;AAC3C,qBAAkB,cAAc;AAChC;;EAEF,MAAM,cAAc,aAAa,IAAI,cAAc;EACnD,MAAM,oBAAoB,KAAK,KAAK,GAAG;AACvC,MAAI,CAAC,eAAe,oBAAoB,YAAY,kBAClD,eAAc,EACZ,eACD,EAAE,KAAK;;CAGZ,SAAS,kBAAkB,KAAK;EAC9B,MAAM,eAAe,aAAa,IAAI,IAAI;AAC1C,MAAI,cAAc,QAChB,cAAa,aAAa,QAAQ;AAEpC,eAAa,OAAO,IAAI;;CAE1B,SAAS,aAAa;AACpB,OAAK,MAAM,OAAO,aAAa,MAAM,CACnC,mBAAkB,IAAI;;CAG1B,SAAS,0BAA0B,8BAA8B,IAAI,KAAK,EAAE;EAC1E,IAAI,yBAAyB;EAC7B,IAAI,wBAAwB,OAAO;AACnC,OAAK,MAAM,SAAS,YAAY,QAAQ,CACtC,KAAI,CAAC,CAAC,MAAM,iBAAiB;AAC3B,2BAAwB,KAAK,IAAI,MAAM,iBAAiB,sBAAsB;AAC9E,4BAAyB,MAAM,0BAA0B;;AAG7D,SAAO;GACL;GACA;GACD;;AAEH,QAAO;;AAIT,IAAI,8BAA8B,EAChC,KACA,SACA,YACA,oBACI;CACJ,MAAM,iBAAiB,UAAU,YAAY,cAAc;CAC3D,MAAM,kBAAkB,WAAW,YAAY,cAAc;CAC7D,MAAM,oBAAoB,YAAY,YAAY,cAAc;CAChE,MAAM,eAAe,EAAE;CACvB,MAAM,WAAW,QAAQ,UAAU;AACjC,MAAI,eAAe,OAAO,EAAE;GAC1B,MAAM,EACJ,WACA,KAAK,EACH,cACA,mBAEA,OAAO;GACX,MAAM,qBAAqB,QAAQ,oBAAoB;GACvD,MAAM,iBAAiB,oBAAoB;AAC3C,OAAI,gBAAgB;IAClB,MAAM,YAAY,EAAE;IACpB,MAAM,iBAAiB,IAAI,SAAS,SAAS,WAAW;AACtD,eAAU,UAAU;AACpB,eAAU,SAAS;MACnB;AACF,mBAAe,YAAY,GACzB;AACF,iBAAa,aAAa;IAC1B,MAAM,WAAW,IAAI,UAAU,cAAc,OAAO,qBAAqB,mBAAmB,GAAG,eAAe,UAAU;IACxH,MAAM,QAAQ,MAAM,UAAU,GAAG,IAAI,WAAW,OAAO;IACvD,MAAM,eAAe;KACnB,GAAG;KACH,qBAAqB,SAAS,MAAM,UAAU,CAAC;KAC/C;KACA;KACA,kBAAkB,qBAAqB,mBAAmB,IAAI,iBAAiB,MAAM,SAAS,IAAI,KAAK,gBAAgB,cAAc,cAAc,aAAa,CAAC,GAAG,KAAK;KACzK;KACD;AACD,mBAAe,cAAc,aAAa;;aAEnC,kBAAkB,OAAO,EAAE;GACpC,MAAM,EACJ,WACA,kBACE,OAAO;AACX,gBAAa,YAAY,QAAQ;IAC/B,MAAM,OAAO;IACb,MAAM;IACP,CAAC;AACF,UAAO,aAAa;aACX,gBAAgB,OAAO,EAAE;GAClC,MAAM,EACJ,WACA,mBACA,kBACE,OAAO;AACX,gBAAa,YAAY,OAAO;IAC9B,OAAO,OAAO,WAAW,OAAO;IAChC,kBAAkB,CAAC;IACnB,MAAM;IACP,CAAC;AACF,UAAO,aAAa;;;AAGxB,QAAO;;AAIT,IAAI,2BAA2B,EAC7B,aACA,SACA,KACA,cACA,oBACI;CACJ,MAAM,EACJ,sBACE,IAAI;CACR,MAAM,WAAW,QAAQ,UAAU;AACjC,MAAI,QAAQ,MAAM,OAAO,CACvB,qBAAoB,OAAO,iBAAiB;AAE9C,MAAI,SAAS,MAAM,OAAO,CACxB,qBAAoB,OAAO,qBAAqB;;CAGpD,SAAS,oBAAoB,MAAM,MAAM;EACvC,MAAM,QAAQ,KAAK,UAAU,CAAC;EAC9B,MAAM,UAAU,MAAM;EACtB,MAAM,gBAAgB,cAAc;AACpC,UAAQ,YAAY;AAClB,QAAK,MAAM,iBAAiB,cAAc,MAAM,EAAE;IAChD,MAAM,gBAAgB,QAAQ;IAC9B,MAAM,uBAAuB,cAAc,IAAI,cAAc;AAC7D,QAAI,CAAC,wBAAwB,CAAC,cAAe;IAC7C,MAAM,SAAS,CAAC,GAAG,qBAAqB,QAAQ,CAAC;AAEjD,QADsB,OAAO,MAAM,QAAQ,IAAI,UAAU,KAAK,IAAI,OAAO,OAAO,QAAQ,IAAI,UAAU,KAAK,EAAE,IAAI,MAAM,OAAO,OAE5H;SAAI,qBAAqB,SAAS,EAChC,MAAK,SAAS,kBAAkB,EAC9B,eACD,CAAC,CAAC;cACM,cAAc,WAAW,gBAClC,MAAK,SAAS,aAAa,cAAc,CAAC;;;IAIhD;;AAEJ,QAAO;;AAIT,SAAS,gBAAgB,OAAO;CAC9B,MAAM,EACJ,aACA,YACA,KACA,SACA,qBACE;CACJ,MAAM,EACJ,WACE;CACJ,MAAM,UAAU,EACd,gBAAgB,aAAa,GAAG,YAAY,iBAAiB,EAC9D;CACD,MAAM,wBAAwB,WAAW,OAAO,KAAK,WAAW,GAAG,YAAY,GAAG;CAClF,MAAM,kBAAkB;EAAC;EAAsB;EAA6B;EAAgC;EAAqB;EAA4B;EAA2B;CACxL,MAAM,cAAc,UAAU;EAC5B,IAAI,eAAe;EACnB,MAAM,gBAAgB,iBAAiB,MAAM,SAAS;EACtD,MAAM,cAAc;GAClB,GAAG;GACH;GACA;GACA;GACA;GACD;EACD,MAAM,WAAW,gBAAgB,KAAK,UAAU,MAAM,YAAY,CAAC;EACnE,MAAM,wBAAwB,2BAA2B,YAAY;EACrE,MAAM,sBAAsB,wBAAwB,YAAY;AAChE,UAAQ,SAAS;AACf,WAAQ,WAAW;AACjB,QAAI,CAAC,SAAS,OAAO,CACnB,QAAO,KAAK,OAAO;AAErB,QAAI,CAAC,cAAc;AACjB,oBAAe;AACf,WAAM,SAAS,IAAI,gBAAgB,qBAAqB,OAAO,CAAC;;IAElE,MAAM,gBAAgB;KACpB,GAAG;KACH;KACD;IACD,MAAM,cAAc,MAAM,UAAU;IACpC,MAAM,CAAC,sBAAsB,uBAAuB,sBAAsB,QAAQ,eAAe,YAAY;IAC7G,IAAI;AACJ,QAAI,qBACF,OAAM,KAAK,OAAO;QAElB,OAAM;AAER,QAAI,CAAC,CAAC,MAAM,UAAU,CAAC,cAAc;AACnC,yBAAoB,QAAQ,eAAe,YAAY;AACvD,SAAI,qBAAqB,OAAO,IAAI,QAAQ,mBAAmB,OAAO,CACpE,MAAK,MAAM,WAAW,SACpB,SAAQ,QAAQ,eAAe,YAAY;;AAIjD,WAAO;;;;AAIb,QAAO;EACL;EACA;EACD;CACD,SAAS,aAAa,eAAe;AACnC,SAAO,MAAM,IAAI,UAAU,cAAc,cAAc,SAAS,cAAc,cAAc;GAC1F,WAAW;GACX,cAAc;GACf,CAAC;;;AAKN,IAAI,iBAAiC,wBAAQ;AAC7C,IAAI,cAAc,EAChB,gBAAgB,kBAAkB,mBAChC,EAAE,MAAM;CACV,MAAM;CACN,KAAK,KAAK,EACR,WACA,UACA,aACA,oBACA,mBACA,2BACA,gBACA,oBACA,sBACA,iBACA,oBACA,wBACC,SAAS;AACV,iBAAe;AACf,aAAW,mBAAmB;EAC9B,MAAM,iBAAiB,QAAQ;AAC7B,OAAI,OAAO,YAAY,eAAe,MACpC;QAAI,CAAC,SAAS,SAAS,IAAI,KAAK,CAC9B,SAAQ,MAAM,aAAa,IAAI,KAAK,gDAAgD;;AAGxF,UAAO;;AAET,SAAO,OAAO,KAAK;GACjB;GACA,WAAW,EAAE;GACb,iBAAiB;IACf;IACA;IACA;IACA;IACD;GACD,MAAM,EAAE;GACT,CAAC;EACF,MAAM,YAAY,eAAe;GAC/B;GACA;GACA,gBAAgB;GACjB,CAAC;EACF,MAAM,EACJ,qBACA,0BACA,oBACA,4BACA,0BACE;AACJ,aAAW,IAAI,MAAM;GACnB;GACA;GACD,CAAC;EACF,MAAM,EACJ,YACA,oBACA,eACA,gBACA,iBACA,iBACA,UACA,2BACE,YAAY;GACd;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACD,CAAC;EACF,MAAM,EACJ,SACA,SAAS,iBACP,WAAW;GACb;GACA;GACA;GACA;GACA;GACA;GACA;GACA,QAAQ;IACN;IACA;IACA;IACA;IACA;IACA;IACD;GACF,CAAC;AACF,aAAW,IAAI,MAAM;GACnB;GACA;GACA;GACA;GACA,eAAe,aAAa;GAC5B,oBAAoB,aAAa;GAClC,CAAC;AACF,aAAW,IAAI,iBAAiB,aAAa;EAC7C,MAAM,mCAAmC,IAAI,SAAS;EACtD,MAAM,oBAAoB,aAAa;AAOrC,UANc,oBAAoB,kBAAkB,iBAAiB;IACnE,sCAAsC,IAAI,KAAK;IAC/C,8BAA8B,IAAI,KAAK;IACvC,gCAAgC,IAAI,KAAK;IACzC,kCAAkC,IAAI,KAAK;IAC5C,EAAE;;EAGL,MAAM,EACJ,oBACA,4BACA,uBACA,yBACA,0BACA,wBACA,yBACE,cAAc;GAChB;GACA;GACA;GACA;GACA;GACA;GACA;GACD,CAAC;AACF,aAAW,IAAI,MAAM;GACnB;GACA;GACA;GACA;GACD,CAAC;EACF,MAAM,EACJ,YACA,SAAS,sBACP,gBAAgB;GAClB;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACD,CAAC;AACF,aAAW,IAAI,MAAM,kBAAkB;AACvC,aAAW,KAAK;GACd;GACA;GACD,CAAC;AACF,SAAO;GACL,MAAM;GACN,eAAe,cAAc,YAAY;IACvC,MAAM,SAAS;IACf,MAAM,WAAW,OAAO,UAAU,kBAAkB,EAAE;AACtD,QAAI,kBAAkB,WAAW,CAC/B,YAAW,UAAU;KACnB,MAAM;KACN,QAAQ,mBAAmB,cAAc,WAAW;KACpD,UAAU,mBAAmB,cAAc,WAAW;KACvD,EAAE,uBAAuB,YAAY,aAAa,CAAC;AAEtD,QAAI,qBAAqB,WAAW,CAClC,YAAW,UAAU;KACnB,MAAM;KACN,QAAQ,uBAAuB;KAC/B,UAAU,sBAAsB,aAAa;KAC9C,EAAE,uBAAuB,eAAe,aAAa,CAAC;AAEzD,QAAI,0BAA0B,WAAW,CACvC,YAAW,UAAU;KACnB,MAAM;KACN,QAAQ,2BAA2B,cAAc,WAAW;KAC5D,UAAU,2BAA2B,cAAc,WAAW;KAC/D,EAAE,uBAAuB,YAAY,aAAa,CAAC;;GAGzD;;CAEJ;AAGD,IAAI,YAA4B,+BAAe,YAAY,CAAC"}